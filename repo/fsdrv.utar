{
  [ "/lib/drivers/fs/devfs" ] = "local X=deepcopy(fs)devfs={}\
function devfs.list(C,G,Y)return udev.getMnemonics()end\
function devfs.exists(ZS,Y,ZX)local WI=udev.getMnemonics()ZX=X.getName(ZX)for i=1,#WI do if\
WI[i]==ZX then return true end end;return false end\
function devfs.open(XH,C,GI,LX)GI=fs.normalizePath(GI)\
local QY=udev.readDevice(X.getName(GI))\
local VF={currentLine=1,text=QY,lines=string.split(QY,\"\\n\"),close=function()end}\
local S=function()local VF=VF;if VF.currentLine>#VF.lines then return nil end;VF.currentLine=\
VF.currentLine+1\
return VF.lines[VF.currentLine-1]end\
local G=function()local VF=VF\
return table.concat(VF.lines,\"\\n\",VF.currentLine)end;VF.readLine=S;VF.readAll=G;return VF end;devfs=applyreadonly(devfs)",
  [ "/lib/drivers" ] = true,
  [ "/lib" ] = true,
  [ "/lib/drivers/fs/ccfs" ] = "ccfs=applyreadonly({})",
  [ "/lib/drivers/fs" ] = true,
  [ "/PKGINFO.lua" ] = "DEPENDS = {\"uberkernel\", \"corelib\"}\
VERSION = {0, 2, 1}",
  [ "/lib/drivers/fs/romfs" ] = "lua.include(\"copy\")local T=deepcopy(fs)romfs={}\
romfs.open=function(J,GR,CC,B)\
J=fsd.normalizePath(J)CC=fsd.normalizePath(CC)\
local W=fsd.normalizePath(string.sub(CC,#J+2,#CC))return T.open(\"/rom\"..W,B)end\
romfs.list=function(Y,AS,DB)Y=fsd.normalizePath(Y)DB=fsd.normalizePath(DB)local ZR=fsd.normalizePath(string.sub(DB,\
#Y+2,#DB))return\
T.list(\"/rom\"..ZR)end\
romfs.isReadOnly=function(WK,OI,LC)WK=fsd.normalizePath(WK)\
LC=fsd.normalizePath(LC)\
local R=fsd.normalizePath(string.sub(LC,#WK+2,#LC))return T.isReadOnly(\"/rom\"..R)end\
romfs.move=function(CG,BV,W)error(\"Filesystem is Read Only!\")end\
romfs.copy=function(IK,L,S,HA)error(\"Copying is not yet implemented!\")end\
romfs.delete=function(HP,NO,A,KC)error(\"Filesystem is Read Only\")end\
romfs.isDir=function(H,EO,F)H=fsd.normalizePath(H)F=fsd.normalizePath(F)local TYY=fsd.normalizePath(string.sub(F,\
#H+2,#F))return\
T.isDir(\"/rom\"..TYY)end\
romfs.exists=function(GV,YX,DD)GV=fsd.normalizePath(GV)\
DD=fsd.normalizePath(DD)\
local QG=fsd.normalizePath(string.sub(DD,#GV+2,#DD))return T.exists(\"/rom\"..QG)end;romfs=applyreadonly(romfs)",
  [ "/lib/drivers/fs/ufs" ] = "ufs={}local V=deepcopy(fs)\
local function CT(M,LC,WY)if not WY then WY={}end\
M=fsd.normalizePath(M)local UY=fsd.stripPath(LC,M)WY[M]=fsd.getInfo(M)\
local E,ND=pcall(fs.list,M)if not E then return WY end;if M==\"/\"then M=\"\"end\
for BH,TE in pairs(ND)do WY[fsd.normalizePath(UY..\"/\"..TE)]=fsd.getInfo(\
M..\"/\"..TE)if\
fs.isDir(M..\"/\"..TE)then CT(M..\"/\"..TE,LC,WY)end end;return WY end\
ufs.saveFs=function(CO,O)local PC=fsd.normalizePath(O)if PC==\"/\"then PC=\"\"end\
local EH=V.open(PC..\"/UFSDATA\",\"w\")local UJ=\"\"\
for W,MF in pairs(CT(CO,CO,{}))do UJ=UJ..W..\
\":\"..MF.owner..\":\"..MF.perms..\":\"if MF.linkto then\
UJ=UJ..MF.linkto end;UJ=UJ..\"\\n\"end;EH.write(UJ)EH.close()end\
ufs.loadFs=function(E,H)local R=fsd.normalizePath(H)if R==\"/\"then R=\"\"end;if not\
V.exists(R..\"/UFSDATA\")then ufs.saveFs(E,H)end\
local GE=V.open(R..\"/UFSDATA\",\"r\")local OW=GE.readAll()GE.close()local EP=string.split(OW,\"\\n\")\
local Y={}\
for HR,P in pairs(EP)do local G=string.split(P,\":\")\
Y[G[1]]={owner=tonumber(G[2]),perms=G[3],linkto=G[4]}if G[4]==\"\"then Y[G[1]].linkto=nil end end;return Y end\
ufs.list=function(ZO,T,PH)PH=fsd.normalizePath(PH)PH=fsd.resolveLinks(PH)\
PH=fsd.stripPath(ZO,PH)\
if not fs.isDir(T..PH)then error(\"Not a directory\")end;local VR=V.list(T..PH)if PH==\"/\"then PH=\"\"end\
for i=1,#VR do if VR[i]then\
local L=PH..\"/\"..VR[i]\
if(L==\"/rom\")or(L==\"/UFSDATA\")then table.remove(VR,i)end end end;return VR end\
ufs.exists=function(GA,AL,P)P=fsd.normalizePath(P)if\
string.sub(AL..P,1,4)==\"/rom\"then return false end;P=fsd.resolveLinks(P)\
P=fsd.stripPath(GA,P)if P==\"/UFSDATA\"then return false end;if GA==P then return true end;return\
V.exists(P)end\
ufs.isDir=function(JT,EB,U)U=fsd.normalizePath(U)if\
string.sub(EB..U..\"/\",1,5)==\"/rom/\"then return false end;U=fsd.resolveLinks(U)\
U=fsd.stripPath(JT,U)if U==\"/UFSDATA\"then return false end;if JT==U then return true end;return\
V.isDir(EB..U)end\
ufs.open=function(Z,I,U,T)U=fsd.resolveLinks(U)U=fsd.stripPath(Z,U)\
if\
fsd.normalizePath(U)==\"/UFSDATA\"then error(\"Internal error\")return end;return V.open(I..U,T)end\
ufs.makeDir=function(N,I,YQ)YQ=fsd.resolveLinks(YQ)YQ=fsd.stripPath(N,YQ)V.makeDir(\
I..YQ)fs.setNode(N..\"/\"..YQ)end\
ufs.move=function(SO,Q,I,X)I=fsd.resolveLinks(I)X=fsd.resolveLinks(X)\
I=fsd.stripPath(SO,I)X=fsd.stripPath(SO,X)V.move(Q..I,Q..X)\
fs.setNode(SO..\"/\"..X)end\
ufs.copy=function(LW,GL,IW,HS)IW=fsd.resolveLinks(IW)HS=fsd.resolveLinks(HS)\
IW=fsd.stripPath(LW,IW)HS=fsd.stripPath(LW,HS)V.copy(GL..IW,GL..HS)fs.setNode(LW..\
\"/\"..HS)end\
ufs.delete=function(SI,Z,FW)FW=fsd.stripPath(SI,FW)\
fsd.setNode(FW,nil,nil,false)V.delete(Z..FW)fs.deleteNode(SI..\"/\"..FW)end;ufs=applyreadonly(ufs)",
}