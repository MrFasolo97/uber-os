{
  [ "/boot" ] = true,
  [ "/lib/modules/lua" ] = "lua={}local CR={\".\",\"/lib\"}local I={}\
function lua.include(IJY)\
for i=1,#I do if I[i]==IJY then return true end end\
for i=1,#CR do\
if fs.exists(CR[i]..\"/\"..IJY..\".lua\")then status=shell.run(CR[i]..\
\"/\"..IJY..\".lua\")if status then\
table.insert(I,IJY)\
kernel.log(\"Loaded library: \"..IJY..\".lua\")return true else\
error(\"Failed to load library: \"..IJY..\".lua\")end end end end;lua=applyreadonly(lua)",
  [ "/lib/modules/users" ] = "local DK=0;local CV={}lua.include(\"split\")users={}function users.getActiveUID()return\
thread.getUID(coroutine.running())end;function users.getUsernameByUID(SY)\
for i=1,#CV do if\
CV[i].uid==SY then return CV[i].name end end;return nil end;function users.getUIDByUsername(DF)\
for i=1,\
#CV do if CV[i].name==DF then return CV[i].uid end end;return nil end;function users.getShell(II)\
for i=1,#CV\
do if CV[i].uid==II then return CV[i].shell end end;return\"/bin/ush\"end;function users.getHome(ZS)\
for i=1,\
#CV do if CV[i].uid==ZS then return CV[i].home end end;return\"/bin/ush\"end\
function users.login(Q,HM)for i=1,\
#CV do\
if(CV[i].name==Q)and(CV[i].pwd==HM)then return true end end;return false end\
local function VU()if not fs.exists(ROOT_DIR..\"/etc/passwd\")then\
kernel.panic(\"/etc/passwd not found!\")end\
local T=fs.open(ROOT_DIR..\"/etc/passwd\",\"r\")local QU=T.readLine()local XD\
while QU do XD=string.split(QU,\":\")\
CV[#CV+1]={name=XD[1],pwd=XD[2],home=XD[6],shell=XD[7],uid=tonumber(XD[3])}QU=T.readLine()end;T.close()end\
function users.newUser(V,PA,N,P)\
if\
thread.getUID(coroutine.running())~=0 then error(\"Only root can create users!\")return end;local RF=1000\
for Y,AI in pairs(CV)do if RF<=AI.uid then RF=AI.uid+1 end end;local K=fs.open(ROOT_DIR..\"/etc/passwd\",\"a\")K.write(V..\
\":\"..PA..\
\":\"..RF..\":::\"..N..\":\"..P)\
K.close()VU()end;VU()users=applyreadonly(users)",
  [ "/lib" ] = true,
  [ "/lib/modules/fsd" ] = "lua.include(\"copy\")lua.include(\"split\")fsd={}local TS={}\
local NP=function(WQ)kernel.log(\
\"Loading Filesystem driver \"..WQ)\
shell.run(\
kernel.root..\"/lib/drivers/fs/\"..WQ)kernel.log(\"Loading Filesystem driver DONE\")end;NP(\"ufs\")NP(\"devfs\")NP(\"romfs\")NP(\"ccfs\")\
local Q=deepcopy(fs)local Y={}local T={}\
function fsd.normalizePerms(V)local BZ=tostring(V)local WN={}\
for i=1,3 do\
local YJ=tonumber(string.sub(BZ,i,i))if YJ==0 then WN[i]=\"---\"end;if YJ==1 then WN[i]=\"--x\"end;if YJ==2 then\
WN[i]=\"-w-\"end;if YJ==3 then WN[i]=\"-wx\"end;if YJ==4 then WN[i]=\"r--\"end;if YJ==\
5 then WN[i]=\"r-x\"end;if YJ==6 then WN[i]=\"rw-\"end;if YJ==7 then\
WN[i]=\"rwx\"end end;return WN end\
function fsd.testPerms(OW,DY,YE)local N=fsd.getInfo(OW)\
local P=fsd.normalizePerms(N.perms)\
if DY==N.owner then\
if YE==\"r\"then return string.sub(P[1],1,1)==\"r\"end\
if YE==\"w\"then return string.sub(P[1],2,2)==\"w\"end\
if YE==\"x\"then return string.sub(P[1],3,3)==\"x\"end else\
if YE==\"r\"then return string.sub(P[3],1,1)==\"r\"end\
if YE==\"w\"then return string.sub(P[3],2,2)==\"w\"end\
if YE==\"x\"then return string.sub(P[3],3,3)==\"x\"end end end\
function fsd.normalizePath(A)if not A then return\"/\"end;A=string.gsub(A,\"/+\",\"/\")if A==\"\"then\
return\"/\"end;if string.sub(A,1,1)~=\"/\"then A=\"/\"..A end;if A==\
\"/\"then return\"/\"end;if string.sub(A,#A,#A)==\"/\"then\
A=string.sub(A,1,#A-1)end;return A end\
function fsd.resolveLinks(ZA)ZA=fsd.normalizePath(ZA)\
local A=string.split(ZA,\"/\")local R=\"/\"for i=1,#A do local LS=A[i]local F=fsd.getInfo(R..LS,true)\
if F.linkto then R=\
fsd.normalizePath(F.linkto)..\"/\"else R=R..LS..\"/\"end end;return\
fsd.normalizePath(R)end\
function fsd.newLink(BRI,UD)\
if\
testPerms(BRI,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(BRI,nil,nil,UD)else error(\"Access denied!\")end end\
function fsd.delLink(IF,BG)if\
testPerms(IF,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(IF,nil,nil,false)else\
error(\"Access denied!\")end end\
function fsd.stripPath(XX,LP)if XX==LP then return\"/\"end;local RT\
RT=fsd.normalizePath(string.sub(fsd.normalizePath(LP),\
#fsd.normalizePath(XX)+1,#fsd.normalizePath(LP)))return RT end\
function fsd.recursList(FZ,J)if not J then J={}end;FZ=fsd.normalizePath(FZ)\
local A=fs.list(FZ)\
for WL,JO in pairs(A)do local DY=fsd.normalizePath(FZ..\"/\"..JO)\
table.insert(J,DY)if fs.isDir(DY)then fsd.recursList(DY,J)end end;return J end\
function fsd.getMount(TM)TM=fsd.normalizePath(TM)\
local TW=string.split(TM,\"/\")for i=2,#TW do TW[i]=TW[i-1]..\"/\"..TW[i]end\
TW[1]=\"/\"local PO=false;for i=#TW,1,-1 do\
for QT,JV in pairs(T)do if TW[i]==QT then\
if PO and(QT~=\"/\")then PO=false else return JV,QT end end end end end\
function fsd.getInfo(R,UO)R=fsd.normalizePath(R)if Y[R]then return Y[R]end;if not UO then\
R=fsd.resolveLinks(R)end;local JT=string.split(R,\"/\")\
for i=1,#JT do if i>1 then JT[i]=JT[i-1]..\"/\"..\
JT[i]end end;JT[1]=\"/\"\
for i=#JT,1,-1 do if Y[JT[i]]then return Y[JT[i]]end end;return{owner=0,perms=777}end;function fsd.saveFs(GC)\
local OU=getfenv()[fsd.getMount(GC).fs].saveFs\
if OU then OU(GC,fsd.getMount(GC).dev)end end\
function fsd.loadFs(R)\
local F=getfenv()[fsd.getMount(R).fs].loadFs\
if F then local G=F(R,fsd.getMount(R).dev)if R==\"/\"then R=\"\"end;for BU,AA in\
pairs(G)do Y[R..BU]=AA end end end\
function fsd.deleteNode(V)if not Y[V]then return end\
if Y[V].onwer==\
thread.getUID(coroutine.running())then Y[V]=nil else error(\"Access denied!\")end end\
function fsd.setNode(ZY,G,HL,HV)ZY=fs.normalizePath(ZY)if not Y[ZY]then\
Y[ZY]=deepcopy(fsd.getInfo(ZY))end;G=G or Y[ZY].owner\
HL=HL or Y[ZY].perms\
if HV==false then HV=nil elseif HV==nil then if Y[ZY].linkto then\
HV=fs.normalizePath(Y[ZY].linkto)end else HV=fs.normalizePath(HV)end;if\
fsd.getInfo(ZY).owner==thread.getUID(coroutine.running())then Y[ZY].owner=G;Y[ZY].perms=HL;Y[ZY].linkto=HV else\
error(\"Access denied!\")end end\
function fsd.mount(GH,LT,AY)if thread then\
if\
thread.getUID(coroutine.running())~=0 then error(\"Superuser is required to mount filesystem\")end end;if\
not getfenv()[LT]then\
kernel.log(\"Unable to mount \"..GH..\" as \"..\
LT..\" on \"..AY..\" : Driver not loaded\")return false end\
AY=fsd.normalizePath(AY)\
if T[AY]then error(\"Filesystem is already mounted\")end\
kernel.log(\"Mounting \"..GH..\" as \"..LT..\" on \"..AY)T[AY]={[\"fs\"]=LT,[\"dev\"]=GH}fsd.loadFs(AY,GH)return true end\
function fsd.umountPath(E)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;E=fsd.normalizePath(E)\
kernel.log(\"Unmounting at \"..E)fsd.saveFs(E)T[E]=nil end\
function fsd.umountDev(XWZ)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;path=fsd.normalizePath(path)\
kernel.log(\"Unmounting \"..XWZ)\
for KN,S in pairs(T)do if S.dev==XWZ then fsd.saveFs(KN)T[KN]=nil end end end;function fsd.getMounts()return T end;function TS.list(AF)AF=fsd.normalizePath(AF)\
if\
fsd.testPerms(AF,thread.getUID(coroutine.running()),\"x\")then else error(\"Access denied!\")end end\
function TS.makeDir(ZF)\
ZF=fsd.normalizePath(ZF)\
if\
fsd.testPerms(Q.getDir(ZF),thread.getUID(coroutine.running()),\"w\")then else error(\"Access denied\")end end\
function TS.copy(ZQ,XHO)ZQ=fsd.normalizePath(ZQ)\
XHO=fsd.normalizePath(XHO)\
if\
fsd.testPerms(ZQ,thread.getUID(coroutine.running()),\"r\")and\
fsd.testPerms(XHO,thread.getUID(coroutine.running()),\"w\")then else\
error(\"Access denied!\")end end\
function TS.move(H,W)H=fsd.normalizePath(H)W=fsd.normalizePath(W)\
if\
fsd.testPerms(Q.getDir(H),thread.getUID(coroutine.running()),\"w\")and\
fsd.testPerms(Q.getDir(W),thread.getUID(coroutine.running()),\"w\")then else\
error(\"Access denied!\")end end\
function TS.delete(YGW)YGW=fsd.normalizePath(YGW)\
if\
fsd.testPerms(Q.getDir(YGW),thread.getUID(coroutine.running()),\"w\")then else error(\"Access denied!\")end end\
function TS.open(XK,LC)XK=fsd.normalizePath(XK)\
local N={r=\"r\",rb=\"r\",w=\"w\",wb=\"w\",a=\"w\",ab=\"w\"}if not N[LC]then error(\"Invalid mode!\")end\
if\
fsd.testPerms(XK,thread.getUID(coroutine.running()),N[LC])then else error(\"Access denied!\")end end;local X=fs.open(kernel.root..\"/etc/fstab\",\"r\")\
for BV,J in\
pairs(string.split(X.readAll(),\"\\n\"))do local G=string.split(J,\" \")fsd.mount(G[1],G[3],G[2])end;X.close()if not T[\"/\"]then\
kernel.panic(\"Unable to mount root filesystem\")end;local B={}\
for LL,AN in pairs(Q)do\
fsd[LL]=function(...)if TS[LL]then\
TS[LL](unpack(arg))end;local V,D;if B[LL]then\
V,D=fsd.getMount(fsd.resolveLinks(arg[1]))V,D=fsd.getMount(Q.getDir(D))else\
V,D=fsd.getMount(fsd.resolveLinks(arg[1]))end;local L\
if\
getfenv()[V.fs]and getfenv()[V.fs][LL]then\
L=getfenv()[V.fs][LL](D,fsd.normalizePath(V.dev),unpack(arg))else L=Q[LL](unpack(arg))end;return L end end;fsd=applyreadonly(fsd)",
  [ "/boot/uberkernel" ] = "\
KERNEL_DIR=fs.getDir(shell.getRunningProgram())local RIQ=false;local YS=print;local GN=write;local HCP=read;local TF=fs\
local QL=coroutine.running()local O={}local ZQ={}local CJ=nil;local FT=false;local RM={}local TU=false;os.unloadAPI(\"io\")\
local DH=error\
error=function(Z)if not Z then DH()return end;if term.isColor()then\
term.setTextColor(colors.red)print(Z)term.setTextColor(colors.white)DH()else\
print(Z)DH()end end;argv={...}local JV={readonlytable}local VE=fs;local D=false;local WM=false;local HLK=false\
local Y=false;local UC={}local NP={}local L=nil\
function applyreadonly(X)local JG={}\
setmetatable(JG,{__index=X,__newindex=function(X,IU,M)\
error(\"Attempt to modify read-only table\")end,__metatable=false})JV[#JV+1]=JG;return JG end;local WO=rawset\
rawset=function(Z,CU,HN)\
for i=1,#JV do if(Z==JV[i])or(CU==JV[i])then\
error(\"Attempt to modify read-only table\")return end end;WO(Z,CU,HN)end\
local function J()term.clear()term.setCursorPos(1,1)\
YS(\"Kernel debug console <CTRL>+T\")\
YS(\"Type 'exit' to leave, 'help' for available commands\")local UN=\"\"local JS={}\
while UN~=\"exit\"do GN(\"> \")UN=HCP(nil,JS)\
if UN==\"exit\"then RIQ=false;return end;if UN==\"help\"then\
YS(\"exit, help, reboot, shutdown, saferb, killbutinit, killall, kill, rbtocraftos, umountall, ps\")end;if UN==\"reboot\"then\
os.reboot()end;if UN==\"shutdown\"then os.shutdown()end;if\
UN==\"saferb\"then os.reboot()end\
if UN==\"killbutinit\"then ZQ={}O={O[1]}end;if UN==\"killall\"then ZQ={}O={}end\
if UN==\"rbtocraftos\"then\
fs.move(ROOT_DIR..\"/startup\",\
ROOT_DIR..\"/.startup_backup\")local F=fs.open(ROOT_DIR..\"/startup\",\"w\")\
F.write(\"ROOT_DIR=fs.getDir(shell.getRunningProgram())\\\
      fs.delete(ROOT_DIR .. '/startup')\\\
      fs.move(ROOT_DIR .. '/.startup_backup', ROOT_DIR .. '/startup')\\\
      print('Be careful! UberOS will start on next reboot!')\")F.close()os.reboot()end;if UN==\"umountall\"then YS(\"WIP\")end;if UN==\"ps\"then for JQ,Z in pairs(O)do\
YS(Z.pid,\" \",Z.desc,\" \",Z.uid)end end\
if\
string.sub(UN,1,5)==\"kill \"then\
if#UN<=5 then YS(\"Usage: kill <PID>\")end;local X=tonumber(string.sub(UN,6,#UN))\
for VEX,JUQ in pairs(O)do if\
JUQ.pid==X then kernel.sendEvent(\"THREADDEAD\",X)\
table.remove(O,VEX)break end end end;table.insert(JS,UN)end;RIQ=false end\
local QP=function()kernel.log(\"Starting thread manager\")\
lua.include(\"copy\")thread={[\"kerneld\"]=0}\
local Z=function()return{isStdin=true}end;local B=function()return{isStdout=true}end\
rawset(thread,\"onPanic\",function(HL)if HL==QL then\
TU=true end end)\
rawset(thread,\"newPID\",function()if not FT then FT=true;return 1 end;local V=true\
while true do\
local OCG=math.random(2,32767)for i=1,#O do if O[i].pid==OCG then V=false;break end end;if V then return\
OCG end end end)\
rawset(thread,\"startThread\",function(PS,U,IRO,M,OQ,H,YVO)if\
thread.getUID(coroutine.running())~=0 then YVO=nil end;local OK=thread.newPID()\
if not M then M=0 end;if not\
((OK==1)or\
(M==thread.getUID(coroutine.running()))or\
(0 ==thread.getUID(coroutine.running())))then\
M=thread.getUID(coroutine.running())end\
table.insert(ZQ,{cr=coroutine.create(PS),blockTerminate=\
U or false,error=nil,dead=false,filter=nil,kill=0,pid=OK,lastevent=kernel.getLastEvent(),ppid=thread.getPID(coroutine.running()),desc=\
IRO or\"\",uid=M,stdin=OQ or Z(),stdout=H or B(),daemon=YVO})return OK,ZQ[#ZQ]end)\
rawset(thread,\"runFile\",function(NM,JF,DK,KX,C,IH,P)\
local M,V=thread.startThread(function()shell.run(NM)end,JF or true,P or NM,KX or\
thread.getUID(coroutine.running()),C,IH,P)if P and\
(thread.getUID(coroutine.running())==0)then V.ppid=1 end;if DK then\
while true do\
local YY,UG,UX,BOO,CC,PI=kernel.pullEvent()if(YY==\"THREADDEAD\")and(UG==M)then return end end else return M end end)\
rawset(thread,\"runDaemon\",function(QF,BG)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot start daemon \"..BG..\" - Access denied!\")return end;if RM[BG]then\
kernel.log(\
\"Daemon \"..BG..\" is already running.\")return end\
local ZZ=thread.runFile(QF,true,false,nil,nil,nil,BG)RM[BG]=ZZ\
fs.open(\"/var/lock/\"..BG,\"w\").close()kernel.log(\"Daemon \"..BG..\" started\")end)\
rawset(thread,\"stopDaemon\",function(CF)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot stop daemon \"..CF..\" - Access denied!\")return end;if not RM[CF]then\
kernel.log(\
\"Daemon \"..CF..\" is not running.\")return end;thread.kill(RM[CF],2)RM[CF]=\
nil;fs.delete(\"/var/lock/\"..CF)kernel.log(\"Daemon \"..\
CF..\" stopped\")end)\
rawset(thread,\"getDaemonStatus\",function(KM)if RM[KM]then return\"running\"else return\"stopped\"end end)\
rawset(thread,\"getLastEvent\",function(HC)if HC==0 then return 0 end\
local GA=thread.status(HC).lastEvent;if GA then return GA else return 0 end end)\
rawset(thread,\"setLastEvent\",function(KN,ZP)thread.status(KN).lastEvent=ZP end)\
rawset(thread,\"kill\",function(WA,PI)\
if WA==1 then kernel.log(\"Failed to kill init\")return end\
for i=1,#O do\
if O[i].pid==WA then\
if\
(O[i].uid==thread.getUID(coroutine.running()))or\
(thread.getUID(coroutine.running())==0)then O[i].kill=PI else\
kernel.log(\
\"Failed to kill process \"..WA..\" - Access Denied\")end end end end)\
rawset(thread,\"isKilled\",function(SL)\
for i=1,#O do if O[i].cr==SL then return O[i].kill end end\
for i=1,#ZQ do if ZQ[i].cr==SL then return ZQ[i].kill end end;return 0 end)\
rawset(thread,\"getPID\",function(AR)\
for i=1,#O do if O[i].cr==AR then return O[i].pid end end\
for i=1,#ZQ do if ZQ[i].cr==AR then return ZQ[i].pid end end;return 0 end)\
rawset(thread,\"getUID\",function(X)\
for i=1,#O do if O[i].cr==X then return O[i].uid end end\
for i=1,#ZQ do if ZQ[i].cr==X then return ZQ[i].uid end end;return 0 end)\
rawset(thread,\"getRunningThreads\",function(RI)return O end)\
rawset(thread,\"status\",function(C)\
for i=1,#O do if O[i].pid==C then return O[i]end end;return nil end)local DLX=print;local W=write;local N=read\
print=function(...)\
local M=thread.status(thread.getPID(coroutine.running())).stdout;if M.isStdout then DLX(unpack(arg))else\
M.writeLine(table.concat(arg,\"\"))end end\
write=function(ID)\
local IU=thread.status(thread.getPID(coroutine.running())).stdout;if IU.isStdout then W(ID)else IU.write(ID)end end\
read=function(QY,TH)\
local HK=thread.status(thread.getPID(coroutine.running()))local VR=HK.stdin;local GA\
if VR.isStdin then GA=N(QY,TH)else GA=VR.readLine()end;return GA end\
local function WOOO(E,M,...)if RIQ then J()return end\
if TU then while true do coroutine.yield()end end;if E.dead then return end\
if E.filter~=nil and M~=E.filter then return end;if M==\"terminate\"then return end\
coroutine.resume(E.cr,M,...)\
E.dead=(coroutine.status(E.cr)==\"dead\")\
if E.dead and E.pid~=1 then local XA=deepcopy(RM)\
for KY,HR in pairs(RM)do if KY==E.daemon then\
kernel.log(\"Daemon \"..\
E.daemon..\" stopped\")XA[KY]=nil end end;RM=XA;kernel.sendEvent(\"THREADDEAD\",E.pid)if\
not E.stdout.isStdout then E.stdout.close()end;if not E.stdin.isStdin then\
E.stdin.close()end end end\
local function JR()if TU then while true do coroutine.yield()end end\
if\
#ZQ>0 then local DKK=ZQ;ZQ={}\
for C,XE in ipairs(DKK)do table.insert(O,XE)end;for NS,M in ipairs(DKK)do WOOO(M)end end;local V;if CJ then V={CJ(coroutine.yield())}else\
V={coroutine.yield()}end\
if V[1]==\"terminate\"then RIQ=not RIQ end;local BWB=nil;for IS,DSL in ipairs(O)do WOOO(DSL,unpack(V))\
if DSL.dead then\
if BWB==nil then BWB={}end;table.insert(BWB,IS-#BWB)end end\
if BWB~=nil then for P,BG in\
ipairs(BWB)do table.remove(O,BG)end end end\
rawset(thread,\"setGlobalEventFilter\",function(ED)\
if CJ~=nil then error(\"This can only be set once!\")end;CJ=ED;rawset(thread,\"setGlobalEventFilter\",nil)end)thread=applyreadonly(thread)\
if type(threadMain)==\"function\"then\
thread.startThread(threadMain)else\
thread.startThread(function()kernel.log(\"Starting init\")\
shell.run(\"/sbin/init\")end,true,\"init\",uid)end;while#O>0 or#ZQ>0 do JR()end\
kernel.log(\"Exiting thread manager\")end;local ZM=os.pullEvent;local I=os.pullEventRaw;kernel={}kernel.root=ROOT_DIR\
kernel.panic=function(F)\
write(\
\"[\"..os.clock()..\"] Kernel panic: \".. (F or\"\"))\
if HLK then print(\" ... no panic is active! Contining...\")else O={}\
ZQ={}while true do sleep(0)end end end\
kernel.log=function(RI)local T=\"[\"..os.clock()..\"] \"..RI;if not WM then\
GN(T..\"\\n\")end;local E\
if Y then\
if VE.exists(ROOT_DIR..\"/var/log/kernel_log\")then E=VE.open(\
ROOT_DIR..\"/var/log/kernel_log\",\"a\")else E=VE.open(\
ROOT_DIR..\"/var/log/kernel_log\",\"w\")end;E.write(T..\"\\n\")E.close()end end\
kernel.loadModule=function(ZR,W)for i=1,#NP do if NP[i]==ZR then return true end end;kernel.log(\
\"Loading module \"..ZR)status,err=pcall(shell.run,ROOT_DIR..\
\"/lib/modules/\"..ZR)\
if status then\
kernel.log(\"Loading module DONE\")table.insert(NP,ZR)return true else\
kernel.log(\"Loading module FAILED\")if W then\
kernel.panic(\"Failed to load module \"..ZR..\"\\nError: \"..err)else\
error(\"Failed to load module\"..ZR..\"\\nError: \"..err)end end end;kernel.getLastEvent=function()return#UC end\
kernel.pullEvent=function()local T=#UC;while\
#UC<=T do\
T=thread.getLastEvent(thread.getPID(coroutine.running()))sleep(0.05)end;thread.setLastEvent(thread.getPID(coroutine.running()),\
T+1)\
return\
UC[T+1].event,UC[T+1].a,UC[T+1].b,UC[T+1].c,UC[T+1].d,UC[T+1].e end\
kernel.sendEvent=function(JVM,M,S,VI,N,Q)\
if JVM==\"THREADDEAD\"then if coroutine.running()~=QL then\
kernel.log(\"Fake THREADDEAD event\")return false end end\
UC[#UC+1]={[\"event\"]=JVM,[\"a\"]=M,[\"b\"]=S,[\"c\"]=VI,[\"d\"]=N,[\"e\"]=Q}return true end;kernel.LISTMODULES=function()\
return fs.list(ROOT_DIR..\"/lib/modules\")end\
kernel.LISTFLAGS=function()return\
{\"Debug\",\"Silent\",\"NoPanic\",\"Log\"}end\
local function DV()\
kernel.log(\"Boot directory = /\"..KERNEL_DIR)\
kernel.log(\"Root directory = /\"..ROOT_DIR)if\
fs.exists(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")then\
fs.delete(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")end\
if\
fs.exists(ROOT_DIR..\"/tmp\")and fs.isDir(ROOT_DIR..\"/tmp\")then for LA,U in pairs(fs.list(ROOT_DIR..\
\"/tmp\"))do\
fs.delete(ROOT_DIR..\"/tmp/\"..U)end\
for UH,ODU in\
pairs(fs.list(ROOT_DIR..\"/var/lock\"))do fs.delete(ROOT_DIR..\"/tmp/\"..ODU)end end\
local V=\".:\"..ROOT_DIR..\"/bin:\"..\
ROOT_DIR..\"/sbin:\"..ROOT_DIR..\"/etc/init.d\"shell.setPath(V)shell.setPath=nil\
shell.setAlias(\"ls\",ROOT_DIR..\"/bin/ls\")shell.setAlias(\"cp\",ROOT_DIR..\"/bin/cp\")shell.setAlias(\"mv\",\
ROOT_DIR..\"/bin/mv\")shell.setAlias(\"rm\",ROOT_DIR..\
\"/bin/rm\")\
shell.setAlias(\"clr\",ROOT_DIR..\"/bin/clear\")shell.setAlias(\"sh\",ROOT_DIR..\"/bin/ush\")\
os.pullEventRaw=function(JM)\
if\
thread then local DT=thread.isKilled(coroutine.running())if\
DT>=2 then\
kernel.log(\"Killed process. PID = \"..thread.getPID(coroutine.running()))error()end;if DT==1 then\
return\"terminate\"end end;return I(JM)end;os.pullEvent=os.pullEventRaw;local JO\
if#argv<=1 then\
kernel.loadModule(\"lua\",true)JO=fs.list(ROOT_DIR..\"/lib/modules\")else JO={}\
for i=2,#argv do if\
string.sub(argv[i],1,1)==\"m\"then\
table.insert(JO,string.sub(argv[i],2,#argv[i]))end end end;for i=1,#JO do kernel.loadModule(JO[i],true)end;if fsd then\
fs=fsd;loadfile=newloadfile end;QP()end;local function K()os.pullEvent=ZM;os.pullEventRaw=I end\
kernel=applyreadonly(kernel)if#argv==0 then return end\
if argv[1]==\"start\"then\
if#argv>1 then\
for i=2,#argv do if argv[i]==\"fDebug\"then\
D=true end;if argv[i]==\"fNoPanic\"then HLK=true end;if\
argv[i]==\"fLog\"then Y=true end;if argv[i]==\"fSilent\"then WM=true end end end;DV()return end;if argv[1]==\"unload\"then K()return end;if argv[1]==\"restart\"then\
os.reboot()end\
if argv[1]==\"stop\"then os.shutdown()end",
  [ "/etc/init.d" ] = true,
  [ "/etc" ] = true,
  [ "/lib/modules" ] = true,
  [ "/etc/init.d/kerneld" ] = "argv={...}if#argv==0 then\
print(\"kerneld start|stop|restart|status\")return end;if argv[1]==\"status\"then\
print(thread.getDaemonStatus(\"kerneld\"))end;if argv[1]==\"start\"then\
shell.run(\"/boot/uberkernel start\")end;if argv[1]==\"stop\"then\
shell.run(\"/boot/uberkernel stop\")end;if argv[1]==\"restart\"then\
shell.run(\"/boot/uberkernel restart\")end",
}