{
  [ "/boot" ] = true,
  [ "/lib/modules/lua" ] = "lua={}local MV={\".\",\"/lib\"}local G={}\
function lua.include(H)\
for i=1,#G do if G[i]==H then return true end end\
for i=1,#MV do\
if fs.exists(MV[i]..\"/\"..H..\".lua\")then status=shell.run(MV[i]..\"/\"..\
H..\".lua\")\
if status then\
table.insert(G,H)\
kernel.log(\"Loaded library: \"..H..\".lua\")return true else\
kernel.log(\"Failed to load library: \"..H..\".lua\")\
error(\"Failed to load library: \"..H..\".lua\")end end end end;lua=applyreadonly(lua)_G[\"lua\"]=lua",
  [ "/lib/modules/users" ] = "local CO=0;local R={}lua.include(\"split\")users={}function users.getActiveUID()return\
thread.getUID(coroutine.running())end;function users.getUsernameByUID(PO)for i=1,#R do if\
R[i].uid==PO then return R[i].name end end\
return nil end;function users.getUIDByUsername(UZ)for i=1,#R do if\
R[i].name==UZ then return R[i].uid end end\
return nil end;function users.getShell(J)for i=1,#R do if\
R[i].uid==J then return R[i].shell end end\
return\"/bin/ush\"end;function users.getHome(U)for i=1,#R do if\
R[i].uid==U then return R[i].home end end\
return\"/bin/ush\"end;function users.login(B,OV)\
for i=1,#R do if\
(R[i].name==B)and(R[i].pwd==OV)then return true end end;return false end\
local function BH()if not fs.exists(\
ROOT_DIR..\"/etc/passwd\")then\
kernel.panic(\"/etc/passwd not found!\")end\
local I=fs.open(ROOT_DIR..\"/etc/passwd\",\"r\")local RF=I.readLine()local B\
while RF do B=string.split(RF,\":\")\
R[#R+1]={name=B[1],pwd=B[2],home=B[6],shell=B[7],uid=tonumber(B[3])}RF=I.readLine()end;I.close()end\
function users.newUser(NB,RLX,WK,QP)\
if\
thread.getUID(coroutine.running())~=0 then error(\"Only root can create users!\")return end;local P=1000\
for GB,ON in pairs(R)do if P<=ON.uid then P=ON.uid+1 end end;local K=fs.open(ROOT_DIR..\"/etc/passwd\",\"a\")K.write(NB..\
\":\"..\
RLX..\":\"..P..\":::\"..WK..\":\"..QP)\
K.close()BH()end;BH()users=applyreadonly(users)_G[\"users\"]=users",
  [ "/lib" ] = true,
  [ "/lib/modules/fsd" ] = "lua.include(\"copy\")lua.include(\"split\")fsd={}local V={}\
local ZH=function(T)kernel.log(\
\"Loading Filesystem driver \"..T)\
shell.run(\
kernel.root..\"/lib/drivers/fs/\"..T)kernel.log(\"Loading Filesystem driver DONE\")end;ZH(\"ufs\")ZH(\"devfs\")ZH(\"romfs\")ZH(\"ccfs\")\
local C=deepcopy(fs)local RU={}local EO={}\
function fsd.normalizePerms(J)local DT=tostring(J)local OS={}\
for i=1,3 do\
local L=tonumber(string.sub(DT,i,i))if L==0 then OS[i]=\"---\"end;if L==1 then OS[i]=\"--x\"end\
if L==2 then OS[i]=\"-w-\"end;if L==3 then OS[i]=\"-wx\"end;if L==4 then OS[i]=\"r--\"end\
if L==5 then OS[i]=\"r-x\"end;if L==6 then OS[i]=\"rw-\"end;if L==7 then OS[i]=\"rwx\"end end;return OS end\
function fsd.testPerms(FX,H,FK)local F=fsd.getInfo(FX)\
local HC=fsd.normalizePerms(F.perms)\
if H==F.owner then\
if FK==\"r\"then return string.sub(HC[1],1,1)==\"r\"end\
if FK==\"w\"then return string.sub(HC[1],2,2)==\"w\"end\
if FK==\"x\"then return string.sub(HC[1],3,3)==\"x\"end else\
if FK==\"r\"then return string.sub(HC[3],1,1)==\"r\"end\
if FK==\"w\"then return string.sub(HC[3],2,2)==\"w\"end\
if FK==\"x\"then return string.sub(HC[3],3,3)==\"x\"end end end\
function fsd.normalizePath(YF)if not YF then return\"/\"end;YF=string.gsub(YF,\"/+\",\"/\")if\
YF==\"\"then return\"/\"end\
if string.sub(YF,1,1)~=\"/\"then YF=\"/\"..YF end;if YF==\"/\"then return\"/\"end;if string.sub(YF,#YF,#YF)==\"/\"then YF=string.sub(YF,1,\
#YF-1)end;return YF end\
function fsd.resolveLinks(U)U=fsd.normalizePath(U)\
local R=string.split(U,\"/\")local N=\"/\"for i=1,#R do local WM=R[i]local TZ=fsd.getInfo(N..WM,true)\
if TZ.linkto then N=\
fsd.normalizePath(TZ.linkto)..\"/\"else N=N..WM..\"/\"end end;return\
fsd.normalizePath(N)end\
function fsd.newLink(CQL,OL)\
if\
testPerms(CQL,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(CQL,nil,nil,OL)else error(\"Access denied!\")end end\
function fsd.delLink(SN,GQ)if\
testPerms(SN,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(SN,nil,nil,false)else\
error(\"Access denied!\")end end\
function fsd.stripPath(JA,AU)if JA==AU then return\"/\"end;local XS\
XS=fsd.normalizePath(string.sub(fsd.normalizePath(AU),\
#fsd.normalizePath(JA)+1,#fsd.normalizePath(AU)))return XS end\
function fsd.recursList(A,R)if not R then R={}end;A=fsd.normalizePath(A)\
local RQ=fs.list(A)\
for X,WP in pairs(RQ)do local KP=fsd.normalizePath(A..\"/\"..WP)\
table.insert(R,KP)if fs.isDir(KP)then fsd.recursList(KP,R)end end;return R end\
function fsd.getMount(PH)PH=fsd.normalizePath(PH)\
local QS=string.split(PH,\"/\")for i=2,#QS do QS[i]=QS[i-1]..\"/\"..QS[i]end\
QS[1]=\"/\"local P=false;for i=#QS,1,-1 do\
for NO,WT in pairs(EO)do if QS[i]==NO then\
if P and(NO~=\"/\")then P=false else return WT,NO end end end end end\
function fsd.getInfo(YY,RY)YY=fsd.normalizePath(YY)if RU[YY]then return RU[YY]end;if\
not RY then YY=fsd.resolveLinks(YY)end\
local MN=string.split(YY,\"/\")\
for i=1,#MN do if i>1 then MN[i]=MN[i-1]..\"/\"..MN[i]end end;MN[1]=\"/\"\
for i=#MN,1,-1 do if RU[MN[i]]then return RU[MN[i]]end end;return{owner=0,perms=777}end\
function fsd.saveFs(M)\
local F=getfenv()[fsd.getMount(M).fs].saveFs;if F then F(M,fsd.getMount(M).dev)end end\
function fsd.loadFs(NS)\
local R=getfenv()[fsd.getMount(NS).fs].loadFs\
if R then local H=R(NS,fsd.getMount(NS).dev)\
if NS==\"/\"then NS=\"\"end;for B,HZ in pairs(H)do RU[NS..B]=HZ end end end\
function fsd.deleteNode(P)if not RU[P]then return end\
if RU[P].onwer==\
thread.getUID(coroutine.running())then RU[P]=nil else error(\"Access denied!\")end end\
function fsd.setNode(T,FF,A,D)T=fs.normalizePath(T)if not RU[T]then\
RU[T]=deepcopy(fsd.getInfo(T))end;FF=FF or RU[T].owner\
A=A or RU[T].perms\
if D==false then D=nil elseif D==nil then if RU[T].linkto then\
D=fs.normalizePath(RU[T].linkto)end else D=fs.normalizePath(D)end;if\
fsd.getInfo(T).owner==thread.getUID(coroutine.running())then RU[T].owner=FF;RU[T].perms=A;RU[T].linkto=D else\
error(\"Access denied!\")end end\
function fsd.mount(P,A,U)if thread then\
if\
thread.getUID(coroutine.running())~=0 then error(\"Superuser is required to mount filesystem\")end end;if\
not getfenv()[A]then\
kernel.log(\"Unable to mount \"..P..\" as \"..\
A..\" on \"..U..\" : Driver not loaded\")return false end;if P==\
\"__ROOT_DEV__\"then P=ROOT_DIR end;U=fsd.normalizePath(U)if EO[U]then\
error(\"Filesystem is already mounted\")end;kernel.log(\"Mounting \"..\
P..\" as \"..A..\" on \"..U)\
EO[U]={[\"fs\"]=A,[\"dev\"]=P}fsd.loadFs(U,P)return true end\
function fsd.umountPath(Y)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;Y=fsd.normalizePath(Y)\
kernel.log(\"Unmounting at \"..Y)fsd.saveFs(Y)EO[Y]=nil end\
function fsd.umountDev(X)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;path=fsd.normalizePath(path)\
kernel.log(\"Unmounting \"..X)\
for J,H in pairs(EO)do if H.dev==X then fsd.saveFs(J)EO[J]=nil end end end;function fsd.getMounts()return EO end;function V.list(T)T=fsd.normalizePath(T)\
if\
fsd.testPerms(T,thread.getUID(coroutine.running()),\"x\")then else error(\"Access denied!\")end end\
function V.makeDir(M)\
M=fsd.normalizePath(M)\
if\
fsd.testPerms(C.getDir(M),thread.getUID(coroutine.running()),\"w\")then else error(\"Access denied\")end end\
function V.copy(SO,G)SO=fsd.normalizePath(SO)G=fsd.normalizePath(G)\
if\
fsd.testPerms(SO,thread.getUID(coroutine.running()),\"r\")and\
fsd.testPerms(G,thread.getUID(coroutine.running()),\"w\")then else\
error(\"Access denied!\")end end\
function V.move(BO,DS)BO=fsd.normalizePath(BO)DS=fsd.normalizePath(DS)\
if\
fsd.testPerms(C.getDir(BO),thread.getUID(coroutine.running()),\"w\")and\
fsd.testPerms(C.getDir(DS),thread.getUID(coroutine.running()),\"w\")then else\
error(\"Access denied!\")end end\
function V.delete(UN)UN=fsd.normalizePath(UN)\
if\
fsd.testPerms(C.getDir(UN),thread.getUID(coroutine.running()),\"w\")then else error(\"Access denied!\")end end\
function V.open(UB,E)UB=fsd.normalizePath(UB)\
local KT={r=\"r\",rb=\"r\",w=\"w\",wb=\"w\",a=\"w\",ab=\"w\"}if not KT[E]then error(\"Invalid mode!\")end\
if\
fsd.testPerms(UB,thread.getUID(coroutine.running()),KT[E])then else error(\"Access denied!\")end end\
local IM=fs.open(kernel.root..\"/etc/fstab\",\"r\")\
for Z,WI in pairs(string.split(IM.readAll(),\"\\n\"))do\
local P=string.split(WI,\" \")fsd.mount(P[1],P[3],P[2])end;IM.close()if not EO[\"/\"]then\
kernel.panic(\"Unable to mount root filesystem\")end;local LV={}\
for KA,N in pairs(C)do\
fsd[KA]=function(...)if V[KA]then\
V[KA](unpack(arg))end;local WI,UP;if LV[KA]then\
WI,UP=fsd.getMount(fsd.resolveLinks(arg[1]))WI,UP=fsd.getMount(C.getDir(UP))else\
WI,UP=fsd.getMount(fsd.resolveLinks(arg[1]))end;local ID\
if\
getfenv()[WI.fs]and getfenv()[WI.fs][KA]then\
ID=getfenv()[WI.fs][KA](UP,fsd.normalizePath(WI.dev),unpack(arg))else ID=C[KA](unpack(arg))end;return ID end end;fsd=applyreadonly(fsd)_G[\"fsd\"]=fsd",
  [ "/boot/uberkernel" ] = "\
KERNEL_DIR=fs.getDir(shell.getRunningProgram())local TQL=false;local VIS=print;local NU=write;local DFS=read;local ZS=fs\
local Q=coroutine.running()local QQ={}local CD={}local QU=nil;local KX=false;local NE={}local NF=false;os.unloadAPI(\"io\")\
local WN=error\
error=function(SET)if not SET then WN()return end;if term.isColor()then\
term.setTextColor(colors.red)print(SET)term.setTextColor(colors.white)WN()else\
print(SET)WN()end end;argv={...}local ZW={readonlytable}local WM=fs;local S=false;local C=false;local EV=false\
local O=false;local SD={}local CYG={}local R=nil\
function applyreadonly(L)local G={}\
setmetatable(G,{__index=L,__newindex=function(L,VK,TM)\
error(\"Attempt to modify read-only table\")end,__metatable=false})ZW[#ZW+1]=G;return G end;local D=rawset\
rawset=function(G,CO,QR)\
for i=1,#ZW do if(G==ZW[i])or(G[CO]==ZW[i])then\
error(\"Attempt to modify read-only table\")return end end;D(G,CO,QR)end\
local function E()term.clear()term.setCursorPos(1,1)\
VIS(\"Kernel debug console <CTRL>+T\")\
VIS(\"Type 'exit' to leave, 'help' for available commands\")local OZJ=\"\"local HU={}\
while OZJ~=\"exit\"do NU(\"> \")OZJ=DFS(nil,HU)\
if OZJ==\"exit\"then TQL=false;return end;if OZJ==\"help\"then\
VIS(\"exit, help, reboot, shutdown, saferb, killbutinit, killall, kill, rbtocraftos, umountall, ps\")end;if OZJ==\"reboot\"then\
os.reboot()end;if OZJ==\"shutdown\"then os.shutdown()end;if OZJ==\
\"saferb\"then os.reboot()end;if OZJ==\"killbutinit\"then CD={}\
QQ={QQ[1]}end;if OZJ==\"killall\"then CD={}QQ={}end\
if\
OZJ==\"rbtocraftos\"then\
fs.move(ROOT_DIR..\"/startup\",ROOT_DIR..\"/.startup_backup\")local TB=fs.open(ROOT_DIR..\"/startup\",\"w\")\
TB.write(\"ROOT_DIR=fs.getDir(shell.getRunningProgram())\\\
      fs.delete(ROOT_DIR .. '/startup')\\\
      fs.move(ROOT_DIR .. '/.startup_backup', ROOT_DIR .. '/startup')\\\
      print('Be careful! UberOS will start on next reboot!')\")TB.close()os.reboot()end;if OZJ==\"umountall\"then VIS(\"WIP\")end;if OZJ==\"ps\"then for SAO,J in pairs(QQ)do\
VIS(J.pid,\" \",J.desc,\" \",J.uid)end end\
if\
string.sub(OZJ,1,5)==\"kill \"then\
if#OZJ<=5 then VIS(\"Usage: kill <PID>\")end;local JI=tonumber(string.sub(OZJ,6,#OZJ))\
for FF,RK in pairs(QQ)do if\
RK.pid==JI then kernel.sendEvent(\"THREADDEAD\",JI)\
table.remove(QQ,FF)break end end end;table.insert(HU,OZJ)end;TQL=false end\
local II=function()kernel.log(\"Starting thread manager\")\
lua.include(\"copy\")thread={[\"kerneld\"]=0}\
local MX=function()return{isStdin=true}end;local MU=function()return{isStdout=true}end\
rawset(thread,\"onPanic\",function(DU)if DU==Q then\
NF=true end end)\
rawset(thread,\"newPID\",function()if not KX then KX=true;return 1 end;local KR=true\
while true do\
local G=math.random(2,32767)\
for i=1,#QQ do if QQ[i].pid==G then KR=false;break end end;if KR then return G end end end)\
rawset(thread,\"startThread\",function(Z,NK,CV,B,ZR,UK,OI)if\
thread.getUID(coroutine.running())~=0 then OI=nil end;local YY=thread.newPID()\
if not B then B=0 end;if not\
((YY==1)or\
(B==thread.getUID(coroutine.running()))or\
(0 ==thread.getUID(coroutine.running())))then\
B=thread.getUID(coroutine.running())end\
table.insert(CD,{cr=coroutine.create(Z),blockTerminate=\
NK or false,error=nil,dead=false,filter=nil,kill=0,pid=YY,lastevent=kernel.getLastEvent(),ppid=thread.getPID(coroutine.running()),desc=\
CV or\"\",uid=B,stdin=ZR or MX(),stdout=UK or MU(),daemon=OI})return YY,CD[#CD]end)\
rawset(thread,\"runFile\",function(GE,IO,OX,VX,CDT,PG,A)\
local AG,K=thread.startThread(function()shell.run(GE)end,IO or true,A or GE,VX or\
thread.getUID(coroutine.running()),CDT,PG,A)if A and\
(thread.getUID(coroutine.running())==0)then K.ppid=1 end;if OX then\
while true do\
local YZ,FH,GF,AD,TC,KP=kernel.pullEvent()if(YZ==\"THREADDEAD\")and(FH==AG)then return end end else return AG end end)\
rawset(thread,\"runDaemon\",function(XS,UQ)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot start daemon \"..UQ..\" - Access denied!\")return end;if NE[UQ]then\
kernel.log(\
\"Daemon \"..UQ..\" is already running.\")return end\
local JK=thread.runFile(XS,true,false,nil,nil,nil,UQ)NE[UQ]=JK\
fs.open(\"/var/lock/\"..UQ,\"w\").close()kernel.log(\"Daemon \"..UQ..\" started\")end)\
rawset(thread,\"stopDaemon\",function(W)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot stop daemon \"..W..\" - Access denied!\")return end;if not NE[W]then\
kernel.log(\
\"Daemon \"..W..\" is not running.\")return end;thread.kill(NE[W],2)NE[W]=\
nil;fs.delete(\"/var/lock/\"..W)kernel.log(\"Daemon \"..\
W..\" stopped\")end)\
rawset(thread,\"getDaemonStatus\",function(ZE)if NE[ZE]then return\"running\"else return\"stopped\"end end)\
rawset(thread,\"getLastEvent\",function(GI)if GI==0 then return 0 end\
local KZ=thread.status(GI).lastEvent;if KZ then return KZ else return 0 end end)\
rawset(thread,\"setLastEvent\",function(RIA,MR)thread.status(RIA).lastEvent=MR end)\
rawset(thread,\"kill\",function(UHN,EK)\
if UHN==1 then kernel.log(\"Failed to kill init\")return end\
for i=1,#QQ do\
if QQ[i].pid==UHN then\
if\
(QQ[i].uid==\
thread.getUID(coroutine.running()))or(\
thread.getUID(coroutine.running())==0)then QQ[i].kill=EK else\
kernel.log(\"Failed to kill process \"..UHN..\" - Access Denied\")end end end end)\
rawset(thread,\"isKilled\",function(FK)\
for i=1,#QQ do if QQ[i].cr==FK then return QQ[i].kill end end\
for i=1,#CD do if CD[i].cr==FK then return CD[i].kill end end;return 0 end)\
rawset(thread,\"getPID\",function(ZK)\
for i=1,#QQ do if QQ[i].cr==ZK then return QQ[i].pid end end\
for i=1,#CD do if CD[i].cr==ZK then return CD[i].pid end end;return 0 end)\
rawset(thread,\"getUID\",function(QL)\
for i=1,#QQ do if QQ[i].cr==QL then return QQ[i].uid end end\
for i=1,#CD do if CD[i].cr==QL then return CD[i].uid end end;return 0 end)\
rawset(thread,\"getRunningThreads\",function(ET)return QQ end)\
rawset(thread,\"status\",function(TW)\
for i=1,#QQ do if QQ[i].pid==TW then return QQ[i]end end;return nil end)local HT=print;local X=write;local U=read\
print=function(...)\
local Y=thread.status(thread.getPID(coroutine.running())).stdout;if Y.isStdout then HT(unpack(arg))else\
Y.writeLine(table.concat(arg,\"\"))end end\
write=function(Y)\
local P=thread.status(thread.getPID(coroutine.running())).stdout;if P.isStdout then X(Y)else P.write(Y)end end\
read=function(J,EA)\
local KM=thread.status(thread.getPID(coroutine.running()))local SN=KM.stdin;local ML\
if SN.isStdin then ML=U(J,EA)else ML=SN.readLine()end;return ML end\
local function WD(TS,Y,...)if TQL then E()return end\
if NF then while true do coroutine.yield()end end;if TS.dead then return end\
if TS.filter~=nil and Y~=TS.filter then return end;if Y==\"terminate\"then return end\
coroutine.resume(TS.cr,Y,...)\
TS.dead=(coroutine.status(TS.cr)==\"dead\")\
if TS.dead and TS.pid~=1 then local GP=deepcopy(NE)\
for IJ,CM in pairs(NE)do if IJ==TS.daemon then\
kernel.log(\
\"Daemon \"..TS.daemon..\" stopped\")GP[IJ]=nil end end;NE=GP;kernel.sendEvent(\"THREADDEAD\",TS.pid)if not\
TS.stdout.isStdout then TS.stdout.close()end;if not\
TS.stdin.isStdin then TS.stdin.close()end end end\
local function NG()if NF then while true do coroutine.yield()end end\
if\
#CD>0 then local JO=CD;CD={}\
for WNA,FS in ipairs(JO)do table.insert(QQ,FS)end;for DT,BN in ipairs(JO)do WD(BN)end end;local UQT;if QU then UQT={QU(coroutine.yield())}else\
UQT={coroutine.yield()}end\
if UQT[1]==\"terminate\"then TQL=not TQL end;local DZV=nil;for J,DF in ipairs(QQ)do WD(DF,unpack(UQT))\
if DF.dead then\
if DZV==nil then DZV={}end;table.insert(DZV,J-#DZV)end end\
if DZV~=nil then for YP,IU in\
ipairs(DZV)do table.remove(QQ,IU)end end end\
rawset(thread,\"setGlobalEventFilter\",function(EX)\
if QU~=nil then error(\"This can only be set once!\")end;QU=EX;rawset(thread,\"setGlobalEventFilter\",nil)end)thread=applyreadonly(thread)_G[\"  thread\"]=thread\
if\
type(threadMain)==\"function\"then thread.startThread(threadMain)else\
thread.startThread(function()\
kernel.log(\"Starting init\")shell.run(\"/sbin/init\")end,true,\"init\",uid)end;while#QQ>0 or#CD>0 do NG()end\
kernel.log(\"Exiting thread manager\")end;local AR=os.pullEvent;local KN=os.pullEventRaw;kernel={}kernel.root=ROOT_DIR\
kernel.panic=function(P)\
write(\
\"[\"..os.clock()..\"] Kernel panic: \".. (P or\"\"))\
if EV then print(\" ... no panic is active! Contining...\")else QQ={}\
CD={}while true do sleep(0)end end end\
kernel.log=function(XO)local CZ=\"[\"..os.clock()..\"] \"..XO;if not C then\
NU(CZ..\"\\n\")end;local Z\
if O then\
if WM.exists(ROOT_DIR..\"/var/log/kernel_log\")then Z=WM.open(\
ROOT_DIR..\"/var/log/kernel_log\",\"a\")else Z=WM.open(\
ROOT_DIR..\"/var/log/kernel_log\",\"w\")end;Z.write(CZ..\"\\n\")Z.close()end end\
kernel.loadModule=function(BW,T)\
for i=1,#CYG do if CYG[i]==BW then return true end end;kernel.log(\"Loading module \"..BW)\
status,err=pcall(shell.run,\
ROOT_DIR..\"/lib/modules/\"..BW)\
if status then kernel.log(\"Loading module DONE\")\
table.insert(CYG,BW)return true else kernel.log(\"Loading module FAILED\")if T then\
kernel.panic(\
\"Failed to load module \"..BW..\"\\nError: \"..err)else\
error(\"Failed to load module\"..BW..\"\\nError: \"..err)end end end;kernel.getLastEvent=function()return#SD end\
kernel.pullEvent=function()local FW=#SD;while#SD<=\
FW do\
FW=thread.getLastEvent(thread.getPID(coroutine.running()))sleep(0.05)end;thread.setLastEvent(thread.getPID(coroutine.running()),\
FW+1)\
return\
SD[FW+1].event,SD[FW+1].a,SD[FW+1].b,SD[FW+1].c,SD[FW+1].d,SD[FW+1].e end\
kernel.sendEvent=function(K,EM,EZL,SJQ,QDY,EY)\
if K==\"THREADDEAD\"then if coroutine.running()~=Q then\
kernel.log(\"Fake THREADDEAD event\")return false end end\
SD[#SD+1]={[\"event\"]=K,[\"a\"]=EM,[\"b\"]=EZL,[\"c\"]=SJQ,[\"d\"]=QDY,[\"e\"]=EY}return true end;kernel.LISTMODULES=function()\
return fs.list(ROOT_DIR..\"/lib/modules\")end\
kernel.LISTFLAGS=function()return\
{\"Debug\",\"Silent\",\"NoPanic\",\"Log\"}end\
local function CGU()\
kernel.log(\"Boot directory = /\"..KERNEL_DIR)\
kernel.log(\"Root directory = /\"..ROOT_DIR)if\
fs.exists(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")then\
fs.delete(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")end\
if\
fs.exists(ROOT_DIR..\"/tmp\")and fs.isDir(ROOT_DIR..\"/tmp\")then for CIR,SMQ in pairs(fs.list(ROOT_DIR..\
\"/tmp\"))do\
fs.delete(ROOT_DIR..\"/tmp/\"..SMQ)end\
for H,W in\
pairs(fs.list(ROOT_DIR..\"/var/lock\"))do fs.delete(ROOT_DIR..\"/tmp/\"..W)end end\
local I=\".:\"..ROOT_DIR..\"/bin:\"..\
ROOT_DIR..\"/sbin:\"..ROOT_DIR..\"/etc/init.d\"shell.setPath(I)shell.setPath=nil\
shell.setAlias(\"ls\",ROOT_DIR..\"/bin/ls\")shell.setAlias(\"cp\",ROOT_DIR..\"/bin/cp\")shell.setAlias(\"mv\",\
ROOT_DIR..\"/bin/mv\")shell.setAlias(\"rm\",ROOT_DIR..\
\"/bin/rm\")\
shell.setAlias(\"clr\",ROOT_DIR..\"/bin/clear\")shell.setAlias(\"sh\",ROOT_DIR..\"/bin/ush\")\
os.pullEventRaw=function(V)\
if\
thread then local ZC=thread.isKilled(coroutine.running())if\
ZC>=2 then\
kernel.log(\"Killed process. PID = \"..thread.getPID(coroutine.running()))error()end;if ZC==1 then\
return\"terminate\"end end;return KN(V)end;os.pullEvent=os.pullEventRaw;local N\
if#argv<=1 then\
kernel.loadModule(\"lua\",true)N=fs.list(ROOT_DIR..\"/lib/modules\")else N={}\
for i=2,#argv do if\
string.sub(argv[i],1,1)==\"m\"then\
table.insert(N,string.sub(argv[i],2,#argv[i]))end end end;for i=1,#N do kernel.loadModule(N[i],true)end;if fsd then\
fs=fsd;_G[\"fs\"]=_G[\"fsd\"]end;II()end;local function F()os.pullEvent=AR;os.pullEventRaw=KN end\
kernel=applyreadonly(kernel)_G[\"kernel\"]=kernel;if#argv==0 then return end\
if argv[1]==\"start\"then\
if#argv>1 then\
for i=2,#\
argv do if argv[i]==\"fDebug\"then S=true end\
if argv[i]==\"fNoPanic\"then EV=true end;if argv[i]==\"fLog\"then O=true end\
if argv[i]==\"fSilent\"then C=true end end end;CGU()return end;if argv[1]==\"unload\"then F()return end;if argv[1]==\"restart\"then\
os.reboot()end\
if argv[1]==\"stop\"then os.shutdown()end",
  [ "/PKGINFO.lua" ] = "DEPENDS = {\"corelib\"}\
VERSION = {0, 2, 1}",
  [ "/etc/init.d" ] = true,
  [ "/etc" ] = true,
  [ "/lib/modules" ] = true,
  [ "/etc/init.d/kerneld" ] = "argv={...}if#argv==0 then\
print(\"kerneld start|stop|restart|status\")return end;if argv[1]==\"status\"then\
print(thread.getDaemonStatus(\"kerneld\"))end;if argv[1]==\"start\"then\
shell.run(\"/boot/uberkernel start\")end;if argv[1]==\"stop\"then\
shell.run(\"/boot/uberkernel stop\")end;if argv[1]==\"restart\"then\
shell.run(\"/boot/uberkernel restart\")end",
}