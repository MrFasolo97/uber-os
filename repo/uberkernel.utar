{
  [ "/boot" ] = true,
  [ "/lib/modules/lua" ] = "lua={}local O={\".\",\"/lib\"}local FB={}\
function lua.include(G)\
for i=1,#FB do if FB[i]==G then return true end end\
for i=1,#O do\
if fs.exists(O[i]..\"/\"..G..\".lua\")then status=shell.run(O[i]..\
\"/\"..G..\".lua\")\
if status then\
table.insert(FB,G)\
kernel.log(\"Loaded library: \"..G..\".lua\")return true else\
kernel.log(\"Failed to load library: \"..G..\".lua\")\
error(\"Failed to load library: \"..G..\".lua\")end end end end;lua=applyreadonly(lua)",
  [ "/lib/modules/users" ] = "local UBZ=0;local I={}lua.include(\"split\")users={}function users.getActiveUID()return\
thread.getUID(coroutine.running())end;function users.getUsernameByUID(X)for i=1,#I do if\
I[i].uid==X then return I[i].name end end\
return nil end;function users.getUIDByUsername(D)for i=1,#I do if\
I[i].name==D then return I[i].uid end end\
return nil end;function users.getShell(OR)for i=1,#I do if\
I[i].uid==OR then return I[i].shell end end\
return\"/bin/ush\"end;function users.getHome(ZT)for i=1,#I do if\
I[i].uid==ZT then return I[i].home end end\
return\"/bin/ush\"end;function users.login(K,PB)\
for i=1,#I do if\
(I[i].name==K)and(I[i].pwd==PB)then return true end end;return false end\
local function AN()if not fs.exists(\
ROOT_DIR..\"/etc/passwd\")then\
kernel.panic(\"/etc/passwd not found!\")end\
local C=fs.open(ROOT_DIR..\"/etc/passwd\",\"r\")local K=C.readLine()local AP\
while K do AP=string.split(K,\":\")\
I[#I+1]={name=AP[1],pwd=AP[2],home=AP[6],shell=AP[7],uid=tonumber(AP[3])}K=C.readLine()end;C.close()end\
function users.newUser(BO,E,NI,L)\
if\
thread.getUID(coroutine.running())~=0 then error(\"Only root can create users!\")return end;local OM=1000\
for ZD,RC in pairs(I)do if OM<=RC.uid then OM=RC.uid+1 end end;local B=fs.open(ROOT_DIR..\"/etc/passwd\",\"a\")B.write(BO..\
\":\"..E..\
\":\"..OM..\":::\"..NI..\":\"..L)\
B.close()AN()end;AN()users=applyreadonly(users)",
  [ "/lib" ] = true,
  [ "/lib/modules/fsd" ] = "lua.include(\"copy\")lua.include(\"split\")fsd={}local SS={}\
local I=function(AA)kernel.log(\
\"Loading Filesystem driver \"..AA)\
shell.run(\
kernel.root..\"/lib/drivers/fs/\"..AA)kernel.log(\"Loading Filesystem driver DONE\")end;I(\"ufs\")I(\"devfs\")I(\"romfs\")I(\"ccfs\")local DN=deepcopy(fs)\
local F={}local M={}\
function fsd.normalizePerms(KP)local KH=tostring(KP)local T={}\
for i=1,3 do\
local AJ=tonumber(string.sub(KH,i,i))if AJ==0 then T[i]=\"---\"end;if AJ==1 then T[i]=\"--x\"end\
if AJ==2 then T[i]=\"-w-\"end;if AJ==3 then T[i]=\"-wx\"end;if AJ==4 then T[i]=\"r--\"end\
if AJ==5 then T[i]=\"r-x\"end;if AJ==6 then T[i]=\"rw-\"end;if AJ==7 then T[i]=\"rwx\"end end;return T end\
function fsd.testPerms(QS,KW,TW)local IK=fsd.getInfo(QS)\
local LXZ=fsd.normalizePerms(IK.perms)\
if KW==IK.owner then\
if TW==\"r\"then return string.sub(LXZ[1],1,1)==\"r\"end\
if TW==\"w\"then return string.sub(LXZ[1],2,2)==\"w\"end\
if TW==\"x\"then return string.sub(LXZ[1],3,3)==\"x\"end else\
if TW==\"r\"then return string.sub(LXZ[3],1,1)==\"r\"end\
if TW==\"w\"then return string.sub(LXZ[3],2,2)==\"w\"end\
if TW==\"x\"then return string.sub(LXZ[3],3,3)==\"x\"end end end\
function fsd.normalizePath(UM)if not UM then return\"/\"end;UM=string.gsub(UM,\"/+\",\"/\")if\
UM==\"\"then return\"/\"end\
if string.sub(UM,1,1)~=\"/\"then UM=\"/\"..UM end;if UM==\"/\"then return\"/\"end;if string.sub(UM,#UM,#UM)==\"/\"then UM=string.sub(UM,1,\
#UM-1)end;return UM end\
function fsd.resolveLinks(S)S=fsd.normalizePath(S)\
local R=string.split(S,\"/\")local J=\"/\"for i=1,#R do local WP=R[i]local XE=fsd.getInfo(J..WP,true)\
if XE.linkto then J=\
fsd.normalizePath(XE.linkto)..\"/\"else J=J..WP..\"/\"end end;return\
fsd.normalizePath(J)end;function fsd.newLink(JS,N)\
if\
testPerms(JS,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(JS,nil,nil,N)else error(\"Access denied!\")end end\
function fsd.delLink(DNV,DB)if\
testPerms(DNV,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(DNV,nil,nil,false)else\
error(\"Access denied!\")end end\
function fsd.stripPath(JG,SY)if JG==SY then return\"/\"end;local LN\
LN=fsd.normalizePath(string.sub(fsd.normalizePath(SY),\
#fsd.normalizePath(JG)+1,#fsd.normalizePath(SY)))return LN end\
function fsd.recursList(UX,H)if not H then H={}end;UX=fsd.normalizePath(UX)\
local IS=fs.list(UX)\
for O,RK in pairs(IS)do local T=fsd.normalizePath(UX..\"/\"..RK)\
table.insert(H,T)if fs.isDir(T)then fsd.recursList(T,H)end end;return H end\
function fsd.getMount(TB)TB=fsd.normalizePath(TB)\
local B=string.split(TB,\"/\")for i=2,#B do B[i]=B[i-1]..\"/\"..B[i]end;B[1]=\"/\"\
local T=false\
for i=#B,1,-1 do for V,D in pairs(M)do\
if B[i]==V then if T and(V~=\"/\")then T=false else return D,V end end end end end\
function fsd.getInfo(GKQ,IK)GKQ=fsd.normalizePath(GKQ)\
if F[GKQ]then return F[GKQ]end;if not IK then GKQ=fsd.resolveLinks(GKQ)end\
local J=string.split(GKQ,\"/\")\
for i=1,#J do if i>1 then J[i]=J[i-1]..\"/\"..J[i]end end;J[1]=\"/\"\
for i=#J,1,-1 do if F[J[i]]then return F[J[i]]end end;return{owner=0,perms=777}end\
function fsd.saveFs(S)\
local GE=getfenv()[fsd.getMount(S).fs].saveFs;if GE then GE(S,fsd.getMount(S).dev)end end\
function fsd.loadFs(D)\
local R=getfenv()[fsd.getMount(D).fs].loadFs\
if R then local Z=R(D,fsd.getMount(D).dev)if D==\"/\"then D=\"\"end;for RPB,KD in\
pairs(Z)do F[D..RPB]=KD end end end\
function fsd.deleteNode(GBL)if not F[GBL]then return end\
if F[GBL].onwer==\
thread.getUID(coroutine.running())then F[GBL]=nil else error(\"Access denied!\")end end\
function fsd.setNode(FZ,J,A,T)FZ=fs.normalizePath(FZ)if not F[FZ]then\
F[FZ]=deepcopy(fsd.getInfo(FZ))end;J=J or F[FZ].owner\
A=A or F[FZ].perms\
if T==false then T=nil elseif T==nil then if F[FZ].linkto then\
T=fs.normalizePath(F[FZ].linkto)end else T=fs.normalizePath(T)end;if\
fsd.getInfo(FZ).owner==thread.getUID(coroutine.running())then F[FZ].owner=J;F[FZ].perms=A;F[FZ].linkto=T else\
error(\"Access denied!\")end end\
function fsd.mount(W,Q,BD)if thread then\
if\
thread.getUID(coroutine.running())~=0 then error(\"Superuser is required to mount filesystem\")end end;if\
not getfenv()[Q]then\
kernel.log(\"Unable to mount \"..W..\" as \"..\
Q..\" on \"..BD..\" : Driver not loaded\")return false end\
BD=fsd.normalizePath(BD)\
if M[BD]then error(\"Filesystem is already mounted\")end\
kernel.log(\"Mounting \"..W..\" as \"..Q..\" on \"..BD)M[BD]={[\"fs\"]=Q,[\"dev\"]=W}fsd.loadFs(BD,W)return true end\
function fsd.umountPath(MM)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;MM=fsd.normalizePath(MM)\
kernel.log(\"Unmounting at \"..MM)fsd.saveFs(MM)M[MM]=nil end\
function fsd.umountDev(E)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;path=fsd.normalizePath(path)\
kernel.log(\"Unmounting \"..E)\
for CY,MQ in pairs(M)do if MQ.dev==E then fsd.saveFs(CY)M[CY]=nil end end end;function fsd.getMounts()return M end;function SS.list(Q)Q=fsd.normalizePath(Q)\
if\
fsd.testPerms(Q,thread.getUID(coroutine.running()),\"x\")then else error(\"Access denied!\")end end\
function SS.makeDir(K)\
K=fsd.normalizePath(K)\
if\
fsd.testPerms(DN.getDir(K),thread.getUID(coroutine.running()),\"w\")then else error(\"Access denied\")end end\
function SS.copy(PD,BT)PD=fsd.normalizePath(PD)BT=fsd.normalizePath(BT)\
if\
fsd.testPerms(PD,thread.getUID(coroutine.running()),\"r\")and\
fsd.testPerms(BT,thread.getUID(coroutine.running()),\"w\")then else\
error(\"Access denied!\")end end\
function SS.move(W,WD)W=fsd.normalizePath(W)WD=fsd.normalizePath(WD)\
if\
fsd.testPerms(DN.getDir(W),thread.getUID(coroutine.running()),\"w\")and\
fsd.testPerms(DN.getDir(WD),thread.getUID(coroutine.running()),\"w\")then else\
error(\"Access denied!\")end end\
function SS.delete(Y)Y=fsd.normalizePath(Y)\
if\
fsd.testPerms(DN.getDir(Y),thread.getUID(coroutine.running()),\"w\")then else error(\"Access denied!\")end end\
function SS.open(A,RS)A=fsd.normalizePath(A)\
local D={r=\"r\",rb=\"r\",w=\"w\",wb=\"w\",a=\"w\",ab=\"w\"}if not D[RS]then error(\"Invalid mode!\")end\
if\
fsd.testPerms(A,thread.getUID(coroutine.running()),D[RS])then else error(\"Access denied!\")end end;local G=fs.open(kernel.root..\"/etc/fstab\",\"r\")for MN,ML in\
pairs(string.split(G.readAll(),\"\\n\"))do local UQ=string.split(ML,\" \")\
fsd.mount(UQ[1],UQ[3],UQ[2])end;G.close()\
if\
not M[\"/\"]then kernel.panic(\"Unable to mount root filesystem\")end;local L={}\
for SD,Z in pairs(DN)do\
fsd[SD]=function(...)\
if SS[SD]then SS[SD](unpack(arg))end;local PK,D;if L[SD]then\
PK,D=fsd.getMount(fsd.resolveLinks(arg[1]))PK,D=fsd.getMount(DN.getDir(D))else\
PK,D=fsd.getMount(fsd.resolveLinks(arg[1]))end;local GD\
if\
getfenv()[PK.fs]and getfenv()[PK.fs][SD]then\
GD=getfenv()[PK.fs][SD](D,fsd.normalizePath(PK.dev),unpack(arg))else GD=DN[SD](unpack(arg))end;return GD end end;fsd=applyreadonly(fsd)",
  [ "/boot/uberkernel" ] = "\
KERNEL_DIR=fs.getDir(shell.getRunningProgram())local QCN=false;local FA=print;local Y=write;local COY=read;local MQ=fs\
local EU=coroutine.running()local D={}local KT={}local I=nil;local JZ=false;local AEJ={}local YJ=false;os.unloadAPI(\"io\")\
local TA=error\
error=function(PUF)if not PUF then TA()return end;if term.isColor()then\
term.setTextColor(colors.red)print(PUF)term.setTextColor(colors.white)TA()else\
print(PUF)TA()end end;argv={...}local NJ={readonlytable}local MW=fs;local H=false;local V=false;local RJ=false\
local KA=false;local FY={}local ZN={}local G=nil\
function applyreadonly(J)local GK={}\
setmetatable(GK,{__index=J,__newindex=function(J,IN,CJC)\
error(\"Attempt to modify read-only table\")end,__metatable=false})NJ[#NJ+1]=GK;return GK end;local R=rawset\
rawset=function(YBI,YRH,BM)\
for i=1,#NJ do if(YBI==NJ[i])or(YRH==NJ[i])then\
error(\"Attempt to modify read-only table\")return end end;R(YBI,YRH,BM)end\
local function B()term.clear()term.setCursorPos(1,1)\
FA(\"Kernel debug console <CTRL>+T\")\
FA(\"Type 'exit' to leave, 'help' for available commands\")local VL=\"\"local GJ={}\
while VL~=\"exit\"do Y(\"> \")VL=COY(nil,GJ)\
if VL==\"exit\"then QCN=false;return end;if VL==\"help\"then\
FA(\"exit, help, reboot, shutdown, saferb, killbutinit, killall, kill, rbtocraftos, umountall, ps\")end;if VL==\"reboot\"then\
os.reboot()end;if VL==\"shutdown\"then os.shutdown()end;if\
VL==\"saferb\"then os.reboot()end\
if VL==\"killbutinit\"then KT={}D={D[1]}end;if VL==\"killall\"then KT={}D={}end\
if VL==\"rbtocraftos\"then\
fs.move(ROOT_DIR..\"/startup\",\
ROOT_DIR..\"/.startup_backup\")local LS=fs.open(ROOT_DIR..\"/startup\",\"w\")\
LS.write(\"ROOT_DIR=fs.getDir(shell.getRunningProgram())\\\
      fs.delete(ROOT_DIR .. '/startup')\\\
      fs.move(ROOT_DIR .. '/.startup_backup', ROOT_DIR .. '/startup')\\\
      print('Be careful! UberOS will start on next reboot!')\")LS.close()os.reboot()end;if VL==\"umountall\"then FA(\"WIP\")end;if VL==\"ps\"then for VZ,FO in pairs(D)do\
FA(FO.pid,\" \",FO.desc,\" \",FO.uid)end end\
if\
string.sub(VL,1,5)==\"kill \"then\
if#VL<=5 then FA(\"Usage: kill <PID>\")end;local T=tonumber(string.sub(VL,6,#VL))\
for BP,PC in pairs(D)do if\
PC.pid==T then kernel.sendEvent(\"THREADDEAD\",T)\
table.remove(D,BP)break end end end;table.insert(GJ,VL)end;QCN=false end\
local P=function()kernel.log(\"Starting thread manager\")\
lua.include(\"copy\")thread={[\"kerneld\"]=0}\
local L=function()return{isStdin=true}end;local PSV=function()return{isStdout=true}end\
rawset(thread,\"onPanic\",function(QE)if QE==EU then\
YJ=true end end)\
rawset(thread,\"newPID\",function()if not JZ then JZ=true;return 1 end;local GR=true\
while true do\
local DC=math.random(2,32767)for i=1,#D do if D[i].pid==DC then GR=false;break end end;if GR then return\
DC end end end)\
rawset(thread,\"startThread\",function(GS,M,IGG,E,HTQ,A,W)if\
thread.getUID(coroutine.running())~=0 then W=nil end;local ZYM=thread.newPID()\
if not E then E=0 end;if not\
((ZYM==1)or\
(E==thread.getUID(coroutine.running()))or\
(0 ==thread.getUID(coroutine.running())))then\
E=thread.getUID(coroutine.running())end\
table.insert(KT,{cr=coroutine.create(GS),blockTerminate=\
M or false,error=nil,dead=false,filter=nil,kill=0,pid=ZYM,lastevent=kernel.getLastEvent(),ppid=thread.getPID(coroutine.running()),desc=\
IGG or\"\",uid=E,stdin=HTQ or L(),stdout=A or PSV(),daemon=W})return ZYM,KT[#KT]end)\
rawset(thread,\"runFile\",function(XL,VQJ,TU,HW,EZ,ZE,IOV)\
local IX,IOF=thread.startThread(function()shell.run(XL)end,VQJ or true,IOV or XL,HW or\
thread.getUID(coroutine.running()),EZ,ZE,IOV)if IOV and\
(thread.getUID(coroutine.running())==0)then IOF.ppid=1 end;if TU then\
while true do\
local K,PR,TN,PU,WM,O=kernel.pullEvent()if(K==\"THREADDEAD\")and(PR==IX)then return end end else return IX end end)\
rawset(thread,\"runDaemon\",function(PU,E)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot start daemon \"..E..\" - Access denied!\")return end;if AEJ[E]then\
kernel.log(\
\"Daemon \"..E..\" is already running.\")return end\
local CX=thread.runFile(PU,true,false,nil,nil,nil,E)AEJ[E]=CX\
fs.open(\"/var/lock/\"..E,\"w\").close()kernel.log(\"Daemon \"..E..\" started\")end)\
rawset(thread,\"stopDaemon\",function(UV)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot stop daemon \"..UV..\" - Access denied!\")return end;if not AEJ[UV]then\
kernel.log(\
\"Daemon \"..UV..\" is not running.\")return end\
thread.kill(AEJ[UV],2)AEJ[UV]=nil;fs.delete(\"/var/lock/\"..UV)kernel.log(\"Daemon \"..UV..\
\" stopped\")end)\
rawset(thread,\"getDaemonStatus\",function(LG)if AEJ[LG]then return\"running\"else return\"stopped\"end end)\
rawset(thread,\"getLastEvent\",function(RL)if RL==0 then return 0 end\
local DR=thread.status(RL).lastEvent;if DR then return DR else return 0 end end)\
rawset(thread,\"setLastEvent\",function(M,UFXL)thread.status(M).lastEvent=UFXL end)\
rawset(thread,\"kill\",function(J,EH)\
if J==1 then kernel.log(\"Failed to kill init\")return end\
for i=1,#D do\
if D[i].pid==J then\
if\
(D[i].uid==thread.getUID(coroutine.running()))or\
(thread.getUID(coroutine.running())==0)then D[i].kill=EH else\
kernel.log(\
\"Failed to kill process \"..J..\" - Access Denied\")end end end end)\
rawset(thread,\"isKilled\",function(ZA)\
for i=1,#D do if D[i].cr==ZA then return D[i].kill end end\
for i=1,#KT do if KT[i].cr==ZA then return KT[i].kill end end;return 0 end)\
rawset(thread,\"getPID\",function(ZJ)\
for i=1,#D do if D[i].cr==ZJ then return D[i].pid end end\
for i=1,#KT do if KT[i].cr==ZJ then return KT[i].pid end end;return 0 end)\
rawset(thread,\"getUID\",function(RX)\
for i=1,#D do if D[i].cr==RX then return D[i].uid end end\
for i=1,#KT do if KT[i].cr==RX then return KT[i].uid end end;return 0 end)\
rawset(thread,\"getRunningThreads\",function(XPH)return D end)\
rawset(thread,\"status\",function(DY)\
for i=1,#D do if D[i].pid==DY then return D[i]end end;return nil end)local NE=print;local UF=write;local Z=read\
print=function(...)\
local F=thread.status(thread.getPID(coroutine.running())).stdout;if F.isStdout then NE(unpack(arg))else\
F.writeLine(table.concat(arg,\"\"))end end\
write=function(BZD)\
local BF=thread.status(thread.getPID(coroutine.running())).stdout;if BF.isStdout then UF(BZD)else BF.write(BZD)end end\
read=function(UA,TD)\
local EN=thread.status(thread.getPID(coroutine.running()))local XC=EN.stdin;local HPA\
if XC.isStdin then HPA=Z(UA,TD)else HPA=XC.readLine()end;return HPA end\
local function OM(IGI,MT,...)if QCN then B()return end\
if YJ then while true do coroutine.yield()end end;if IGI.dead then return end\
if IGI.filter~=nil and MT~=IGI.filter then return end;if MT==\"terminate\"then return end\
coroutine.resume(IGI.cr,MT,...)\
IGI.dead=(coroutine.status(IGI.cr)==\"dead\")\
if IGI.dead and IGI.pid~=1 then local RC=deepcopy(AEJ)\
for WH,IGR in pairs(AEJ)do if WH==IGI.daemon then\
kernel.log(\
\"Daemon \"..IGI.daemon..\" stopped\")RC[WH]=nil end end;AEJ=RC;kernel.sendEvent(\"THREADDEAD\",IGI.pid)if not\
IGI.stdout.isStdout then IGI.stdout.close()end;if not\
IGI.stdin.isStdin then IGI.stdin.close()end end end\
local function ZTE()if YJ then while true do coroutine.yield()end end\
if\
#KT>0 then local BH=KT;KT={}for YK,FP in ipairs(BH)do table.insert(D,FP)end;for PN,DM in\
ipairs(BH)do OM(DM)end end;local OA;if I then OA={I(coroutine.yield())}else\
OA={coroutine.yield()}end\
if OA[1]==\"terminate\"then QCN=not QCN end;local BC=nil\
for T,IC in ipairs(D)do OM(IC,unpack(OA))if IC.dead then if BC==nil then BC={}end;table.insert(BC,\
T-#BC)end end\
if BC~=nil then for YT,A in ipairs(BC)do table.remove(D,A)end end end\
rawset(thread,\"setGlobalEventFilter\",function(T)\
if I~=nil then error(\"This can only be set once!\")end;I=T;rawset(thread,\"setGlobalEventFilter\",nil)end)thread=applyreadonly(thread)\
if type(threadMain)==\"function\"then\
thread.startThread(threadMain)else\
thread.startThread(function()kernel.log(\"Starting init\")\
shell.run(\"/sbin/init\")end,true,\"init\",uid)end;while#D>0 or#KT>0 do ZTE()end\
kernel.log(\"Exiting thread manager\")end;local MC=os.pullEvent;local X=os.pullEventRaw;kernel={}kernel.root=ROOT_DIR\
kernel.panic=function(YS)\
write(\
\"[\"..os.clock()..\"] Kernel panic: \".. (YS or\"\"))\
if RJ then print(\" ... no panic is active! Contining...\")else D={}\
KT={}while true do sleep(0)end end end\
kernel.log=function(PJ)local AX=\"[\"..os.clock()..\"] \"..PJ;if not V then\
Y(AX..\"\\n\")end;local IZF\
if KA then\
if\
MW.exists(ROOT_DIR..\"/var/log/kernel_log\")then\
IZF=MW.open(ROOT_DIR..\"/var/log/kernel_log\",\"a\")else\
IZF=MW.open(ROOT_DIR..\"/var/log/kernel_log\",\"w\")end;IZF.write(AX..\"\\n\")IZF.close()end end\
kernel.loadModule=function(VL,RM)for i=1,#ZN do if ZN[i]==VL then return true end end;kernel.log(\
\"Loading module \"..VL)status,err=pcall(shell.run,ROOT_DIR..\
\"/lib/modules/\"..VL)\
if status then\
kernel.log(\"Loading module DONE\")table.insert(ZN,VL)return true else\
kernel.log(\"Loading module FAILED\")if RM then\
kernel.panic(\"Failed to load module \"..VL..\"\\nError: \"..err)else\
error(\"Failed to load module\"..VL..\"\\nError: \"..err)end end end;kernel.getLastEvent=function()return#FY end\
kernel.pullEvent=function()local Q=#FY;while\
#FY<=Q do\
Q=thread.getLastEvent(thread.getPID(coroutine.running()))sleep(0.05)end;thread.setLastEvent(thread.getPID(coroutine.running()),\
Q+1)\
return\
FY[Q+1].event,FY[Q+1].a,FY[Q+1].b,FY[Q+1].c,FY[Q+1].d,FY[Q+1].e end\
kernel.sendEvent=function(FI,O,JP,FD,DS,J)\
if FI==\"THREADDEAD\"then if coroutine.running()~=EU then\
kernel.log(\"Fake THREADDEAD event\")return false end end\
FY[#FY+1]={[\"event\"]=FI,[\"a\"]=O,[\"b\"]=JP,[\"c\"]=FD,[\"d\"]=DS,[\"e\"]=J}return true end;kernel.LISTMODULES=function()\
return fs.list(ROOT_DIR..\"/lib/modules\")end\
kernel.LISTFLAGS=function()return\
{\"Debug\",\"Silent\",\"NoPanic\",\"Log\"}end\
local function C()\
kernel.log(\"Boot directory = /\"..KERNEL_DIR)\
kernel.log(\"Root directory = /\"..ROOT_DIR)if\
fs.exists(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")then\
fs.delete(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")end\
if\
fs.exists(ROOT_DIR..\"/tmp\")and fs.isDir(ROOT_DIR..\"/tmp\")then for FD,YIC in pairs(fs.list(ROOT_DIR..\
\"/tmp\"))do\
fs.delete(ROOT_DIR..\"/tmp/\"..YIC)end\
for M,HK in\
pairs(fs.list(ROOT_DIR..\"/var/lock\"))do fs.delete(ROOT_DIR..\"/tmp/\"..HK)end end\
local RR=\".:\"..ROOT_DIR..\"/bin:\"..\
ROOT_DIR..\"/sbin:\"..ROOT_DIR..\"/etc/init.d\"shell.setPath(RR)shell.setPath=nil\
shell.setAlias(\"ls\",ROOT_DIR..\"/bin/ls\")shell.setAlias(\"cp\",ROOT_DIR..\"/bin/cp\")shell.setAlias(\"mv\",\
ROOT_DIR..\"/bin/mv\")shell.setAlias(\"rm\",ROOT_DIR..\
\"/bin/rm\")\
shell.setAlias(\"clr\",ROOT_DIR..\"/bin/clear\")shell.setAlias(\"sh\",ROOT_DIR..\"/bin/ush\")\
os.pullEventRaw=function(F)\
if\
thread then local M=thread.isKilled(coroutine.running())if\
M>=2 then\
kernel.log(\"Killed process. PID = \"..thread.getPID(coroutine.running()))error()end\
if M==1 then return\"terminate\"end end;return X(F)end;os.pullEvent=os.pullEventRaw;local KF\
if#argv<=1 then\
kernel.loadModule(\"lua\",true)KF=fs.list(ROOT_DIR..\"/lib/modules\")else KF={}\
for i=2,#argv do if\
string.sub(argv[i],1,1)==\"m\"then\
table.insert(KF,string.sub(argv[i],2,#argv[i]))end end end;for i=1,#KF do kernel.loadModule(KF[i],true)end;if fsd then\
fs=fsd;loadfile=newloadfile end;P()end;local function PH()os.pullEvent=MC;os.pullEventRaw=X end\
kernel=applyreadonly(kernel)if#argv==0 then return end\
if argv[1]==\"start\"then\
if#argv>1 then\
for i=2,#argv do if argv[i]==\"fDebug\"then\
H=true end;if argv[i]==\"fNoPanic\"then RJ=true end;if\
argv[i]==\"fLog\"then KA=true end;if argv[i]==\"fSilent\"then V=true end end end;C()return end;if argv[1]==\"unload\"then PH()return end;if argv[1]==\"restart\"then\
os.reboot()end\
if argv[1]==\"stop\"then os.shutdown()end",
  [ "/PKGINFO.lua" ] = "DEPENDS = {\"corelib\"}\
VERSION = {0, 2, 1}",
  [ "/etc/init.d" ] = true,
  [ "/etc" ] = true,
  [ "/lib/modules" ] = true,
  [ "/etc/init.d/kerneld" ] = "argv={...}if#argv==0 then\
print(\"kerneld start|stop|restart|status\")return end;if argv[1]==\"status\"then\
print(thread.getDaemonStatus(\"kerneld\"))end;if argv[1]==\"start\"then\
shell.run(\"/boot/uberkernel start\")end;if argv[1]==\"stop\"then\
shell.run(\"/boot/uberkernel stop\")end;if argv[1]==\"restart\"then\
shell.run(\"/boot/uberkernel restart\")end",
}