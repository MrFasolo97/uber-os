{
  [ "/boot" ] = true,
  [ "/lib/modules/lua" ] = "lua={}local QS={\".\",\"/lib\"}local L={}\
function lua.include(ND)\
for i=1,#L do if L[i]==ND then return true end end\
for i=1,#QS do\
if fs.exists(QS[i]..\"/\"..ND..\".lua\")then status=shell.run(QS[i]..\"/\"..ND..\
\".lua\")\
if status then\
table.insert(L,ND)\
kernel.log(\"Loaded library: \"..ND..\".lua\")return true else\
kernel.log(\"Failed to load library: \"..ND..\".lua\")\
error(\"Failed to load library: \"..ND..\".lua\")end end end end;lua=applyreadonly(lua)",
  [ "/lib/modules/users" ] = "local NV=0;local YS={}lua.include(\"split\")users={}function users.getActiveUID()return\
thread.getUID(coroutine.running())end;function users.getUsernameByUID(T)\
for i=1,#YS do if\
YS[i].uid==T then return YS[i].name end end;return nil end;function users.getUIDByUsername(I)\
for i=1,\
#YS do if YS[i].name==I then return YS[i].uid end end;return nil end;function users.getShell(IH)\
for i=1,#YS do if\
YS[i].uid==IH then return YS[i].shell end end;return\"/bin/ush\"end;function users.getHome(EF)\
for i=1,\
#YS do if YS[i].uid==EF then return YS[i].home end end;return\"/bin/ush\"end\
function users.login(LT,D)for i=1,\
#YS do\
if(YS[i].name==LT)and(YS[i].pwd==D)then return true end end;return false end\
local function S()if not fs.exists(ROOT_DIR..\"/etc/passwd\")then\
kernel.panic(\"/etc/passwd not found!\")end\
local HK=fs.open(ROOT_DIR..\"/etc/passwd\",\"r\")local ML=HK.readLine()local Y\
while ML do Y=string.split(ML,\":\")\
YS[#YS+1]={name=Y[1],pwd=Y[2],home=Y[6],shell=Y[7],uid=tonumber(Y[3])}ML=HK.readLine()end;HK.close()end\
function users.newUser(ZA,GM,NG,QY)\
if\
thread.getUID(coroutine.running())~=0 then error(\"Only root can create users!\")return end;local G=1000\
for GV,B in pairs(YS)do if G<=B.uid then G=B.uid+1 end end;local TP=fs.open(ROOT_DIR..\"/etc/passwd\",\"a\")TP.write(ZA..\
\
\":\"..GM..\":\"..G..\":::\"..NG..\":\"..QY)\
TP.close()S()end;S()users=applyreadonly(users)",
  [ "/lib" ] = true,
  [ "/lib/modules/fsd" ] = "lua.include(\"copy\")lua.include(\"split\")fsd={}local MMU={}\
local EV=function(OT)kernel.log(\
\"Loading Filesystem driver \"..OT)\
shell.run(\
kernel.root..\"/lib/drivers/fs/\"..OT)kernel.log(\"Loading Filesystem driver DONE\")end;EV(\"ufs\")EV(\"devfs\")EV(\"romfs\")EV(\"ccfs\")\
local GH=deepcopy(fs)local TAC={}local XE={}\
function fsd.normalizePerms(QA)local GD=tostring(QA)local AQ={}\
for i=1,3 do\
local Q=tonumber(string.sub(GD,i,i))if Q==0 then AQ[i]=\"---\"end;if Q==1 then AQ[i]=\"--x\"end\
if Q==2 then AQ[i]=\"-w-\"end;if Q==3 then AQ[i]=\"-wx\"end;if Q==4 then AQ[i]=\"r--\"end\
if Q==5 then AQ[i]=\"r-x\"end;if Q==6 then AQ[i]=\"rw-\"end;if Q==7 then AQ[i]=\"rwx\"end end;return AQ end\
function fsd.testPerms(N,OP,KO)local PG=fsd.getInfo(N)\
local G=fsd.normalizePerms(PG.perms)\
if OP==PG.owner then\
if KO==\"r\"then return string.sub(G[1],1,1)==\"r\"end\
if KO==\"w\"then return string.sub(G[1],2,2)==\"w\"end\
if KO==\"x\"then return string.sub(G[1],3,3)==\"x\"end else\
if KO==\"r\"then return string.sub(G[3],1,1)==\"r\"end\
if KO==\"w\"then return string.sub(G[3],2,2)==\"w\"end\
if KO==\"x\"then return string.sub(G[3],3,3)==\"x\"end end end\
function fsd.normalizePath(Y)if not Y then return\"/\"end;Y=string.gsub(Y,\"/+\",\"/\")if Y==\"\"then\
return\"/\"end;if string.sub(Y,1,1)~=\"/\"then Y=\"/\"..Y end;if Y==\
\"/\"then return\"/\"end;if string.sub(Y,#Y,#Y)==\"/\"then\
Y=string.sub(Y,1,#Y-1)end;return Y end\
function fsd.resolveLinks(EM)EM=fsd.normalizePath(EM)\
local ZD=string.split(EM,\"/\")local TW=\"/\"for i=1,#ZD do local KO=ZD[i]local U=fsd.getInfo(TW..KO,true)\
if U.linkto then TW=\
fsd.normalizePath(U.linkto)..\"/\"else TW=TW..KO..\"/\"end end;return\
fsd.normalizePath(TW)end;function fsd.newLink(XO,OD)\
if\
testPerms(XO,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(XO,nil,nil,OD)else error(\"Access denied!\")end end;function fsd.delLink(P,K)\
if\
testPerms(P,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(P,nil,nil,false)else error(\"Access denied!\")end end\
function fsd.stripPath(DT,TW)if\
DT==TW then return\"/\"end;local P\
P=fsd.normalizePath(string.sub(fsd.normalizePath(TW),#\
fsd.normalizePath(DT)+1,#fsd.normalizePath(TW)))return P end\
function fsd.recursList(IA,QM)if not QM then QM={}end;IA=fsd.normalizePath(IA)\
local Y=fs.list(IA)\
for BQ,WD in pairs(Y)do local A=fsd.normalizePath(IA..\"/\"..WD)\
table.insert(QM,A)if fs.isDir(A)then fsd.recursList(A,QM)end end;return QM end\
function fsd.getMount(KC)KC=fsd.normalizePath(KC)\
local LG=string.split(KC,\"/\")for i=2,#LG do LG[i]=LG[i-1]..\"/\"..LG[i]end\
LG[1]=\"/\"local JD=false;for i=#LG,1,-1 do\
for P,PJ in pairs(XE)do if LG[i]==P then\
if JD and(P~=\"/\")then JD=false else return PJ,P end end end end end\
function fsd.getInfo(F,G)F=fsd.normalizePath(F)if TAC[F]then return TAC[F]end;if not G then\
F=fsd.resolveLinks(F)end;local M=string.split(F,\"/\")for i=1,#M do if i>1 then M[i]=M[i-1]..\
\"/\"..M[i]end end\
M[1]=\"/\"\
for i=#M,1,-1 do if TAC[M[i]]then return TAC[M[i]]end end;return{owner=0,perms=777}end;function fsd.saveFs(TY)\
local JJH=getfenv()[fsd.getMount(TY).fs].saveFs\
if JJH then JJH(TY,fsd.getMount(TY).dev)end end\
function fsd.loadFs(M)\
local R=getfenv()[fsd.getMount(M).fs].loadFs\
if R then local CQ=R(M,fsd.getMount(M).dev)if M==\"/\"then M=\"\"end;for S,YE in\
pairs(CQ)do TAC[M..S]=YE end end end\
function fsd.deleteNode(OE)if not TAC[OE]then return end\
if TAC[OE].onwer==\
thread.getUID(coroutine.running())then TAC[OE]=nil else error(\"Access denied!\")end end\
function fsd.setNode(JN,D,HC,V)JN=fs.normalizePath(JN)if not TAC[JN]then\
TAC[JN]=deepcopy(fsd.getInfo(JN))end;D=D or TAC[JN].owner\
HC=HC or TAC[JN].perms\
if V==false then V=nil elseif V==nil then if TAC[JN].linkto then\
V=fs.normalizePath(TAC[JN].linkto)end else V=fs.normalizePath(V)end;if\
fsd.getInfo(JN).owner==thread.getUID(coroutine.running())then TAC[JN].owner=D;TAC[JN].perms=HC;TAC[JN].linkto=V else\
error(\"Access denied!\")end end\
function fsd.mount(D,IR,V)if thread then\
if\
thread.getUID(coroutine.running())~=0 then error(\"Superuser is required to mount filesystem\")end end;if\
not getfenv()[IR]then\
kernel.log(\"Unable to mount \"..D..\" as \"..\
IR..\" on \"..V..\" : Driver not loaded\")return false end\
V=fsd.normalizePath(V)\
if XE[V]then error(\"Filesystem is already mounted\")end\
kernel.log(\"Mounting \"..D..\" as \"..IR..\" on \"..V)XE[V]={[\"fs\"]=IR,[\"dev\"]=D}fsd.loadFs(V,D)return true end\
function fsd.umountPath(K)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;K=fsd.normalizePath(K)\
kernel.log(\"Unmounting at \"..K)fsd.saveFs(K)XE[K]=nil end\
function fsd.umountDev(KP)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;path=fsd.normalizePath(path)\
kernel.log(\"Unmounting \"..KP)\
for AF,LO in pairs(XE)do if LO.dev==KP then fsd.saveFs(AF)XE[AF]=nil end end end;function fsd.getMounts()return XE end;function MMU.list(F)F=fsd.normalizePath(F)\
if\
fsd.testPerms(F,thread.getUID(coroutine.running()),\"x\")then else error(\"Access denied!\")end end\
function MMU.makeDir(JB)\
JB=fsd.normalizePath(JB)\
if\
fsd.testPerms(GH.getDir(JB),thread.getUID(coroutine.running()),\"w\")then else error(\"Access denied\")end end\
function MMU.copy(S,Q)S=fsd.normalizePath(S)Q=fsd.normalizePath(Q)\
if\
fsd.testPerms(S,thread.getUID(coroutine.running()),\"r\")and\
fsd.testPerms(Q,thread.getUID(coroutine.running()),\"w\")then else\
error(\"Access denied!\")end end\
function MMU.move(G,D)G=fsd.normalizePath(G)D=fsd.normalizePath(D)\
if\
fsd.testPerms(GH.getDir(G),thread.getUID(coroutine.running()),\"w\")and\
fsd.testPerms(GH.getDir(D),thread.getUID(coroutine.running()),\"w\")then else\
error(\"Access denied!\")end end\
function MMU.delete(MH)MH=fsd.normalizePath(MH)\
if\
fsd.testPerms(GH.getDir(MH),thread.getUID(coroutine.running()),\"w\")then else error(\"Access denied!\")end end\
function MMU.open(M,W)M=fsd.normalizePath(M)\
local FK={r=\"r\",rb=\"r\",w=\"w\",wb=\"w\",a=\"w\",ab=\"w\"}if not FK[W]then error(\"Invalid mode!\")end\
if\
fsd.testPerms(M,thread.getUID(coroutine.running()),FK[W])then else error(\"Access denied!\")end end;local J=fs.open(kernel.root..\"/etc/fstab\",\"r\")for U,X in\
pairs(string.split(J.readAll(),\"\\n\"))do local UK=string.split(X,\" \")\
fsd.mount(UK[1],UK[3],UK[2])end;J.close()\
if\
not XE[\"/\"]then kernel.panic(\"Unable to mount root filesystem\")end;local YZ={}\
for Z,V in pairs(GH)do\
fsd[Z]=function(...)\
if MMU[Z]then MMU[Z](unpack(arg))end;local W,P;if YZ[Z]then\
W,P=fsd.getMount(fsd.resolveLinks(arg[1]))W,P=fsd.getMount(GH.getDir(P))else\
W,P=fsd.getMount(fsd.resolveLinks(arg[1]))end;local ZQ\
if\
getfenv()[W.fs]and getfenv()[W.fs][Z]then\
ZQ=getfenv()[W.fs][Z](P,fsd.normalizePath(W.dev),unpack(arg))else ZQ=GH[Z](unpack(arg))end;return ZQ end end;fsd=applyreadonly(fsd)",
  [ "/boot/uberkernel" ] = "\
KERNEL_DIR=fs.getDir(shell.getRunningProgram())local IH=false;local SC=print;local X=write;local TTS=read;local F=fs\
local RS=coroutine.running()local XHG={}local KWF={}local FV=nil;local TLI=false;local FH={}local JO=false;os.unloadAPI(\"io\")\
local EK=error\
error=function(ROJ)if not ROJ then EK()return end;if term.isColor()then\
term.setTextColor(colors.red)print(ROJ)term.setTextColor(colors.white)EK()else\
print(ROJ)EK()end end;argv={...}local N={readonlytable}local L=fs;local J=false;local YO=false;local R=false\
local OY=false;local FO={}local UZ={}local Z=nil\
function applyreadonly(G)local W={}\
setmetatable(W,{__index=G,__newindex=function(G,S,RC)\
error(\"Attempt to modify read-only table\")end,__metatable=false})N[#N+1]=W;return W end;local AW=rawset\
rawset=function(HF,ZU,ZF)\
for i=1,#N do if(HF==N[i])or(ZU==N[i])then\
error(\"Attempt to modify read-only table\")return end end;AW(HF,ZU,ZF)end\
local function U()term.clear()term.setCursorPos(1,1)\
SC(\"Kernel debug console <CTRL>+T\")\
SC(\"Type 'exit' to leave, 'help' for available commands\")local XJ=\"\"local JJ={}\
while XJ~=\"exit\"do X(\"> \")XJ=TTS(nil,JJ)\
if XJ==\"exit\"then IH=false;return end;if XJ==\"help\"then\
SC(\"exit, help, reboot, shutdown, saferb, killbutinit, killall, kill, rbtocraftos, umountall, ps\")end;if XJ==\"reboot\"then\
os.reboot()end;if XJ==\"shutdown\"then os.shutdown()end;if\
XJ==\"saferb\"then os.reboot()end\
if XJ==\"killbutinit\"then KWF={}XHG={XHG[1]}end;if XJ==\"killall\"then KWF={}XHG={}end\
if XJ==\"rbtocraftos\"then\
fs.move(ROOT_DIR..\"/startup\",\
ROOT_DIR..\"/.startup_backup\")local E=fs.open(ROOT_DIR..\"/startup\",\"w\")\
E.write(\"ROOT_DIR=fs.getDir(shell.getRunningProgram())\\\
      fs.delete(ROOT_DIR .. '/startup')\\\
      fs.move(ROOT_DIR .. '/.startup_backup', ROOT_DIR .. '/startup')\\\
      print('Be careful! UberOS will start on next reboot!')\")E.close()os.reboot()end;if XJ==\"umountall\"then SC(\"WIP\")end;if XJ==\"ps\"then for P,PH in pairs(XHG)do\
SC(PH.pid,\" \",PH.desc,\" \",PH.uid)end end\
if\
string.sub(XJ,1,5)==\"kill \"then\
if#XJ<=5 then SC(\"Usage: kill <PID>\")end;local ZP=tonumber(string.sub(XJ,6,#XJ))\
for K,DF in pairs(XHG)do if\
DF.pid==ZP then kernel.sendEvent(\"THREADDEAD\",ZP)\
table.remove(XHG,K)break end end end;table.insert(JJ,XJ)end;IH=false end\
local NG=function()kernel.log(\"Starting thread manager\")\
lua.include(\"copy\")thread={[\"kerneld\"]=0}\
local T=function()return{isStdin=true}end;local IO=function()return{isStdout=true}end\
rawset(thread,\"onPanic\",function(ZOS)if ZOS==RS then\
JO=true end end)\
rawset(thread,\"newPID\",function()if not TLI then TLI=true;return 1 end;local M=true\
while true do\
local WZ=math.random(2,32767)\
for i=1,#XHG do if XHG[i].pid==WZ then M=false;break end end;if M then return WZ end end end)\
rawset(thread,\"startThread\",function(FU,QH,SK,GD,I,SX,ETG)if\
thread.getUID(coroutine.running())~=0 then ETG=nil end;local IG=thread.newPID()\
if not GD then GD=0 end;if not\
((IG==1)or\
(GD==thread.getUID(coroutine.running()))or\
(0 ==thread.getUID(coroutine.running())))then\
GD=thread.getUID(coroutine.running())end\
table.insert(KWF,{cr=coroutine.create(FU),blockTerminate=\
QH or false,error=nil,dead=false,filter=nil,kill=0,pid=IG,lastevent=kernel.getLastEvent(),ppid=thread.getPID(coroutine.running()),desc=\
SK or\"\",uid=GD,stdin=I or T(),stdout=SX or IO(),daemon=ETG})return IG,KWF[#KWF]end)\
rawset(thread,\"runFile\",function(WD,UE,RU,B,Y,DG,YFR)\
local GC,YG=thread.startThread(function()shell.run(WD)end,UE or true,YFR or WD,B or\
thread.getUID(coroutine.running()),Y,DG,YFR)if YFR and\
(thread.getUID(coroutine.running())==0)then YG.ppid=1 end;if RU then\
while true do\
local UX,LZ,CQ,JS,A,JV=kernel.pullEvent()if(UX==\"THREADDEAD\")and(LZ==GC)then return end end else return GC end end)\
rawset(thread,\"runDaemon\",function(DF,WT)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot start daemon \"..WT..\" - Access denied!\")return end;if FH[WT]then\
kernel.log(\
\"Daemon \"..WT..\" is already running.\")return end\
local UW=thread.runFile(DF,true,false,nil,nil,nil,WT)FH[WT]=UW\
fs.open(\"/var/lock/\"..WT,\"w\").close()kernel.log(\"Daemon \"..WT..\" started\")end)\
rawset(thread,\"stopDaemon\",function(WQ)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot stop daemon \"..WQ..\" - Access denied!\")return end;if not FH[WQ]then\
kernel.log(\
\"Daemon \"..WQ..\" is not running.\")return end;thread.kill(FH[WQ],2)FH[WQ]=\
nil;fs.delete(\"/var/lock/\"..WQ)kernel.log(\"Daemon \"..\
WQ..\" stopped\")end)\
rawset(thread,\"getDaemonStatus\",function(M)if FH[M]then return\"running\"else return\"stopped\"end end)\
rawset(thread,\"getLastEvent\",function(K)if K==0 then return 0 end\
local UR=thread.status(K).lastEvent;if UR then return UR else return 0 end end)\
rawset(thread,\"setLastEvent\",function(I,IE)thread.status(I).lastEvent=IE end)\
rawset(thread,\"kill\",function(PA,EJ)\
if PA==1 then kernel.log(\"Failed to kill init\")return end\
for i=1,#XHG do\
if XHG[i].pid==PA then\
if\
(XHG[i].uid==\
thread.getUID(coroutine.running()))or(\
thread.getUID(coroutine.running())==0)then XHG[i].kill=EJ else\
kernel.log(\"Failed to kill process \"..PA..\" - Access Denied\")end end end end)\
rawset(thread,\"isKilled\",function(H)\
for i=1,#XHG do if XHG[i].cr==H then return XHG[i].kill end end\
for i=1,#KWF do if KWF[i].cr==H then return KWF[i].kill end end;return 0 end)\
rawset(thread,\"getPID\",function(D)\
for i=1,#XHG do if XHG[i].cr==D then return XHG[i].pid end end\
for i=1,#KWF do if KWF[i].cr==D then return KWF[i].pid end end;return 0 end)\
rawset(thread,\"getUID\",function(UQ)\
for i=1,#XHG do if XHG[i].cr==UQ then return XHG[i].uid end end\
for i=1,#KWF do if KWF[i].cr==UQ then return KWF[i].uid end end;return 0 end)\
rawset(thread,\"getRunningThreads\",function(AE)return XHG end)\
rawset(thread,\"status\",function(DU)\
for i=1,#XHG do if XHG[i].pid==DU then return XHG[i]end end;return nil end)local TT=print;local ZZ=write;local V=read\
print=function(...)\
local LC=thread.status(thread.getPID(coroutine.running())).stdout;if LC.isStdout then TT(unpack(arg))else\
LC.writeLine(table.concat(arg,\"\"))end end\
write=function(JQ)\
local NO=thread.status(thread.getPID(coroutine.running())).stdout;if NO.isStdout then ZZ(JQ)else NO.write(JQ)end end\
read=function(RJH,S)\
local XHV=thread.status(thread.getPID(coroutine.running()))local PK=XHV.stdin;local ZN\
if PK.isStdin then ZN=V(RJH,S)else ZN=PK.readLine()end;return ZN end\
local function VO(JBX,XI,...)if IH then U()return end\
if JO then while true do coroutine.yield()end end;if JBX.dead then return end\
if JBX.filter~=nil and XI~=JBX.filter then return end;if XI==\"terminate\"then return end\
coroutine.resume(JBX.cr,XI,...)\
JBX.dead=(coroutine.status(JBX.cr)==\"dead\")\
if JBX.dead and JBX.pid~=1 then local S=deepcopy(FH)\
for GX,QM in pairs(FH)do if GX==JBX.daemon then\
kernel.log(\
\"Daemon \"..JBX.daemon..\" stopped\")S[GX]=nil end end;FH=S;kernel.sendEvent(\"THREADDEAD\",JBX.pid)if not\
JBX.stdout.isStdout then JBX.stdout.close()end;if not\
JBX.stdin.isStdin then JBX.stdin.close()end end end\
local function E()if JO then while true do coroutine.yield()end end\
if\
#KWF>0 then local TK=KWF;KWF={}\
for JE,XT in ipairs(TK)do table.insert(XHG,XT)end;for UU,JMS in ipairs(TK)do VO(JMS)end end;local JB;if FV then JB={FV(coroutine.yield())}else\
JB={coroutine.yield()}end\
if JB[1]==\"terminate\"then IH=not IH end;local LX=nil\
for WW,JBC in ipairs(XHG)do VO(JBC,unpack(JB))if JBC.dead then if LX==nil then LX={}end;table.insert(LX,\
WW-#LX)end end\
if LX~=nil then for Q,MZ in ipairs(LX)do table.remove(XHG,MZ)end end end\
rawset(thread,\"setGlobalEventFilter\",function(QE)\
if FV~=nil then error(\"This can only be set once!\")end;FV=QE;rawset(thread,\"setGlobalEventFilter\",nil)end)thread=applyreadonly(thread)\
if type(threadMain)==\"function\"then\
thread.startThread(threadMain)else\
thread.startThread(function()kernel.log(\"Starting init\")\
shell.run(\"/sbin/init\")end,true,\"init\",uid)end;while#XHG>0 or#KWF>0 do E()end\
kernel.log(\"Exiting thread manager\")end;local BH=os.pullEvent;local PD=os.pullEventRaw;kernel={}kernel.root=ROOT_DIR\
kernel.panic=function(B)\
write(\
\"[\"..os.clock()..\"] Kernel panic: \".. (B or\"\"))\
if R then print(\" ... no panic is active! Contining...\")else XHG={}\
KWF={}while true do sleep(0)end end end\
kernel.log=function(HY)local A=\"[\"..os.clock()..\"] \"..HY;if not YO then\
X(A..\"\\n\")end;local MU\
if OY then\
if L.exists(ROOT_DIR..\"/var/log/kernel_log\")then MU=L.open(\
ROOT_DIR..\"/var/log/kernel_log\",\"a\")else MU=L.open(\
ROOT_DIR..\"/var/log/kernel_log\",\"w\")end;MU.write(A..\"\\n\")MU.close()end end\
kernel.loadModule=function(KF,M)for i=1,#UZ do if UZ[i]==KF then return true end end;kernel.log(\
\"Loading module \"..KF)status,err=pcall(shell.run,ROOT_DIR..\
\"/lib/modules/\"..KF)\
if status then\
kernel.log(\"Loading module DONE\")table.insert(UZ,KF)return true else\
kernel.log(\"Loading module FAILED\")if M then\
kernel.panic(\"Failed to load module \"..KF..\"\\nError: \"..err)else\
error(\"Failed to load module\"..KF..\"\\nError: \"..err)end end end;kernel.getLastEvent=function()return#FO end\
kernel.pullEvent=function()local RE=#FO;while#FO<=\
RE do\
RE=thread.getLastEvent(thread.getPID(coroutine.running()))sleep(0.05)end;thread.setLastEvent(thread.getPID(coroutine.running()),\
RE+1)\
return\
FO[RE+1].event,FO[RE+1].a,FO[RE+1].b,FO[RE+1].c,FO[RE+1].d,FO[RE+1].e end\
kernel.sendEvent=function(T,YT,MT,G,Q,W)\
if T==\"THREADDEAD\"then if coroutine.running()~=RS then\
kernel.log(\"Fake THREADDEAD event\")return false end end\
FO[#FO+1]={[\"event\"]=T,[\"a\"]=YT,[\"b\"]=MT,[\"c\"]=G,[\"d\"]=Q,[\"e\"]=W}return true end;kernel.LISTMODULES=function()\
return fs.list(ROOT_DIR..\"/lib/modules\")end\
kernel.LISTFLAGS=function()return\
{\"Debug\",\"Silent\",\"NoPanic\",\"Log\"}end\
local function GE()\
kernel.log(\"Boot directory = /\"..KERNEL_DIR)\
kernel.log(\"Root directory = /\"..ROOT_DIR)if\
fs.exists(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")then\
fs.delete(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")end\
if\
fs.exists(ROOT_DIR..\"/tmp\")and fs.isDir(ROOT_DIR..\"/tmp\")then for EH,IU in pairs(fs.list(ROOT_DIR..\
\"/tmp\"))do\
fs.delete(ROOT_DIR..\"/tmp/\"..IU)end\
for LN,C in\
pairs(fs.list(ROOT_DIR..\"/var/lock\"))do fs.delete(ROOT_DIR..\"/tmp/\"..C)end end\
local TH=\".:\"..ROOT_DIR..\"/bin:\"..\
ROOT_DIR..\"/sbin:\"..ROOT_DIR..\"/etc/init.d\"shell.setPath(TH)shell.setPath=nil\
shell.setAlias(\"ls\",ROOT_DIR..\"/bin/ls\")shell.setAlias(\"cp\",ROOT_DIR..\"/bin/cp\")shell.setAlias(\"mv\",\
ROOT_DIR..\"/bin/mv\")shell.setAlias(\"rm\",ROOT_DIR..\
\"/bin/rm\")\
shell.setAlias(\"clr\",ROOT_DIR..\"/bin/clear\")shell.setAlias(\"sh\",ROOT_DIR..\"/bin/ush\")\
os.pullEventRaw=function(QW)\
if\
thread then local GJ=thread.isKilled(coroutine.running())if\
GJ>=2 then\
kernel.log(\"Killed process. PID = \"..thread.getPID(coroutine.running()))error()end;if GJ==1 then\
return\"terminate\"end end;return PD(QW)end;os.pullEvent=os.pullEventRaw;local MH\
if#argv<=1 then\
kernel.loadModule(\"lua\",true)MH=fs.list(ROOT_DIR..\"/lib/modules\")else MH={}\
for i=2,#argv do if\
string.sub(argv[i],1,1)==\"m\"then\
table.insert(MH,string.sub(argv[i],2,#argv[i]))end end end;for i=1,#MH do kernel.loadModule(MH[i],true)end;if fsd then\
fs=fsd;loadfile=newloadfile end;NG()end;local function O()os.pullEvent=BH;os.pullEventRaw=PD end\
kernel=applyreadonly(kernel)if#argv==0 then return end\
if argv[1]==\"start\"then\
if#argv>1 then\
for i=2,#argv do if argv[i]==\"fDebug\"then\
J=true end;if argv[i]==\"fNoPanic\"then R=true end;if\
argv[i]==\"fLog\"then OY=true end;if argv[i]==\"fSilent\"then YO=true end end end;GE()return end;if argv[1]==\"unload\"then O()return end;if argv[1]==\"restart\"then\
os.reboot()end\
if argv[1]==\"stop\"then os.shutdown()end",
  [ "/PKGINFO.lua" ] = "DEPENDS = {\"corelib\"}\
VERSION = {0, 2, 1}",
  [ "/etc/init.d" ] = true,
  [ "/etc" ] = true,
  [ "/lib/modules" ] = true,
  [ "/etc/init.d/kerneld" ] = "argv={...}if#argv==0 then\
print(\"kerneld start|stop|restart|status\")return end;if argv[1]==\"status\"then\
print(thread.getDaemonStatus(\"kerneld\"))end;if argv[1]==\"start\"then\
shell.run(\"/boot/uberkernel start\")end;if argv[1]==\"stop\"then\
shell.run(\"/boot/uberkernel stop\")end;if argv[1]==\"restart\"then\
shell.run(\"/boot/uberkernel restart\")end",
}