{
  [ "/boot" ] = true,
  [ "/lib/modules/lua" ] = "lua={}local AX={\".\",\"/lib\"}local EQ={}\
function lua.include(O)\
for i=1,#EQ do if EQ[i]==O then return true end end\
for i=1,#AX do\
if fs.exists(AX[i]..\"/\"..O..\".lua\")then status=shell.run(AX[i]..\"/\"..\
O..\".lua\")\
if status then\
table.insert(EQ,O)\
kernel.log(\"Loaded library: \"..O..\".lua\")return true else\
kernel.log(\"Failed to load library: \"..O..\".lua\")\
error(\"Failed to load library: \"..O..\".lua\")end end end end;lua=applyreadonly(lua)_G[\"lua\"]=lua",
  [ "/lib/modules/users" ] = "local J=0;local NC={}lua.include(\"split\")users={}function users.getActiveUID()return\
thread.getUID(coroutine.running())end;function users.getUsernameByUID(S)\
for i=1,#NC do if\
NC[i].uid==S then return NC[i].name end end;return nil end;function users.getUIDByUsername(X)\
for i=1,\
#NC do if NC[i].name==X then return NC[i].uid end end;return nil end;function users.getShell(IM)\
for i=1,#NC do if\
NC[i].uid==IM then return NC[i].shell end end;return\"/bin/ush\"end;function users.getHome(A)\
for i=1,\
#NC do if NC[i].uid==A then return NC[i].home end end;return\"/bin/ush\"end\
function users.login(UI,A)for i=1,\
#NC do\
if(NC[i].name==UI)and(NC[i].pwd==A)then return true end end;return false end\
local function W()if not fs.exists(ROOT_DIR..\"/etc/passwd\")then\
kernel.panic(\"/etc/passwd not found!\")end;local VY\
if thread then VY=\"\"else VY=ROOT_DIR end;local G=fs.open(VY..\"/etc/passwd\",\"r\")\
local C=G.readLine()local GMK\
while C do GMK=string.split(C,\":\")\
NC[#NC+1]={name=GMK[1],pwd=GMK[2],home=GMK[6],shell=GMK[7],uid=tonumber(GMK[3])}C=G.readLine()end;G.close()end\
function users.newUser(L,P,HZ,IO)\
if\
thread.getUID(coroutine.running())~=0 then error(\"Only root can create users!\")return end;local D=1000\
for AX,VT in pairs(NC)do if D<=VT.uid then D=VT.uid+1 end end;local F=fs.open(ROOT_DIR..\"/etc/passwd\",\"a\")F.write(L..\
\":\"..P..\
\":\"..D..\":::\"..HZ..\":\"..IO)\
F.close()W()end;W()users=applyreadonly(users)_G[\"users\"]=users",
  [ "/lib" ] = true,
  [ "/lib/modules/fsd" ] = "lua.include(\"copy\")lua.include(\"split\")fsd={}fsdf={}\
local S=function(JF)kernel.log(\
\"Loading Filesystem driver \"..JF)\
shell.run(\
kernel.root..\"/lib/drivers/fs/\"..JF)kernel.log(\"Loading Filesystem driver DONE\")end;S(\"ufs\")S(\"devfs\")S(\"romfs\")S(\"ccfs\")local XK=deepcopy(fs)\
local B={}local J={}\
function fsd.normalizePerms(SB)local F=tostring(SB)local C={}\
for i=1,3 do\
local FJ=tonumber(string.sub(F,i,i))if FJ==0 then C[i]=\"---\"end;if FJ==1 then C[i]=\"--x\"end\
if FJ==2 then C[i]=\"-w-\"end;if FJ==3 then C[i]=\"-wx\"end;if FJ==4 then C[i]=\"r--\"end\
if FJ==5 then C[i]=\"r-x\"end;if FJ==6 then C[i]=\"rw-\"end;if FJ==7 then C[i]=\"rwx\"end end;return C end\
function fsd.testPerms(P,K,JI)local UC=fsd.getInfo(P)\
local SP=fsd.normalizePerms(UC.perms)\
if K==UC.owner then\
if JI==\"r\"then return string.sub(SP[1],1,1)==\"r\"end\
if JI==\"w\"then return string.sub(SP[1],2,2)==\"w\"end\
if JI==\"x\"then return string.sub(SP[1],3,3)==\"x\"end else\
if JI==\"r\"then return string.sub(SP[3],1,1)==\"r\"end\
if JI==\"w\"then return string.sub(SP[3],2,2)==\"w\"end\
if JI==\"x\"then return string.sub(SP[3],3,3)==\"x\"end end end\
function fsd.normalizePath(MM)if not MM then return\"/\"end;MM=string.gsub(MM,\"/+\",\"/\")if\
MM==\"\"then return\"/\"end\
if string.sub(MM,1,1)~=\"/\"then MM=\"/\"..MM end;if MM==\"/\"then return\"/\"end;if string.sub(MM,#MM,#MM)==\"/\"then MM=string.sub(MM,1,\
#MM-1)end;return MM end\
function fsd.resolveLinks(SB)SB=fsd.normalizePath(SB)\
local QA=string.split(SB,\"/\")local WI=\"/\"for i=1,#QA do local TD=QA[i]local Q=fsd.getInfo(WI..TD,true)\
if Q.linkto then WI=\
fsd.normalizePath(Q.linkto)..\"/\"else WI=WI..TD..\"/\"end end;return\
fsd.normalizePath(WI)end;function fsd.newLink(TV,Z)\
if\
testPerms(TV,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(TV,nil,nil,Z)else error(\"Access denied!\")end end\
function fsd.delLink(NO,D)if\
testPerms(NO,thread.getUID(coroutine.running()),\"w\")then fsd.setNode(NO,nil,nil,false)else\
error(\"Access denied!\")end end\
function fsd.stripPath(X,HW)if X==HW then return\"/\"end;local OLQ\
OLQ=fsd.normalizePath(string.sub(fsd.normalizePath(HW),\
#fsd.normalizePath(X)+1,#fsd.normalizePath(HW)))return OLQ end\
function fsd.recursList(HF,ZN)if not ZN then ZN={}end;HF=fsd.normalizePath(HF)\
local KA=fs.list(HF)\
for KE,IN in pairs(KA)do local YW=fsd.normalizePath(HF..\"/\"..IN)\
table.insert(ZN,YW)if fs.isDir(YW)then fsd.recursList(YW,ZN)end end;return ZN end\
function fsd.getMount(JUN)JUN=fsd.normalizePath(JUN)\
local P=string.split(JUN,\"/\")for i=2,#P do P[i]=P[i-1]..\"/\"..P[i]end;P[1]=\"/\"\
local FO=false;for i=#P,1,-1 do\
for PU,D in pairs(J)do if P[i]==PU then\
if FO and(PU~=\"/\")then FO=false else return D,PU end end end end end\
function fsd.getInfo(HA,A)HA=fsd.normalizePath(HA)if B[HA]then return B[HA]end;if not A then\
HA=fsd.resolveLinks(HA)end;local OHM=string.split(HA,\"/\")\
for i=1,#OHM do if i>1 then OHM[i]=\
OHM[i-1]..\"/\"..OHM[i]end end;OHM[1]=\"/\"\
for i=#OHM,1,-1 do if B[OHM[i]]then return B[OHM[i]]end end;return{owner=0,perms=777}end\
function fsd.saveFs(AH)\
local Q=getfenv()[fsd.getMount(AH).fs].saveFs;if Q then Q(AH,fsd.getMount(AH).dev)end end\
function fsd.loadFs(EJ)\
local X=getfenv()[fsd.getMount(EJ).fs].loadFs\
if X then local SZO=X(EJ,fsd.getMount(EJ).dev)\
if EJ==\"/\"then EJ=\"\"end;for A,AGY in pairs(SZO)do B[EJ..A]=AGY end end end\
function fsd.deleteNode(GP)if not B[GP]then return end\
if B[GP].onwer==\
thread.getUID(coroutine.running())then B[GP]=nil else error(\"Access denied!\")end end\
function fsd.setNode(V,UF,LE,ZQ)V=fs.normalizePath(V)if not B[V]then\
B[V]=deepcopy(fsd.getInfo(V))end;UF=UF or B[V].owner\
LE=LE or B[V].perms\
if ZQ==false then ZQ=nil elseif ZQ==nil then if B[V].linkto then\
ZQ=fs.normalizePath(B[V].linkto)end else ZQ=fs.normalizePath(ZQ)end;if\
fsd.getInfo(V).owner==thread.getUID(coroutine.running())then B[V].owner=UF;B[V].perms=LE;B[V].linkto=ZQ else\
error(\"Access denied!\")end end\
function fsd.mount(RM,PY,R)if thread then\
if\
thread.getUID(coroutine.running())~=0 then error(\"Superuser is required to mount filesystem\")end end;if\
not getfenv()[PY]then\
kernel.log(\"Unable to mount \"..RM..\" as \"..\
PY..\" on \"..R..\" : Driver not loaded\")return false end;if RM==\
\"__ROOT_DEV__\"then RM=ROOT_DIR end;R=fsd.normalizePath(R)\
if\
J[R]then error(\"Filesystem is already mounted\")end\
kernel.log(\"Mounting \"..RM..\" as \"..PY..\" on \"..R)J[R]={[\"fs\"]=PY,[\"dev\"]=RM}fsd.loadFs(R,RM)return true end\
function fsd.umountPath(H)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;H=fsd.normalizePath(H)\
kernel.log(\"Unmounting at \"..H)fsd.saveFs(H)J[H]=nil end\
function fsd.umountDev(QN)\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Superuser is required to unmount filesystem\")end end;path=fsd.normalizePath(path)\
kernel.log(\"Unmounting \"..QN)\
for WP,RY in pairs(J)do if RY.dev==QN then fsd.saveFs(WP)J[WP]=nil end end end;function fsd.getMounts()return J end\
function fsdf.list(H)H=fsd.normalizePath(H)\
if\
fsd.testPerms(H,thread.getUID(coroutine.running()),\"x\")then return true else return false,\"Access denied!\"end end\
function fsdf.makeDir(VI)VI=fsd.normalizePath(VI)\
if\
fsd.testPerms(XK.getDir(VI),thread.getUID(coroutine.running()),\"w\")then return true else return false,\"Access denied\"end end\
function fsdf.copy(FZ,EI)FZ=fsd.normalizePath(FZ)\
EI=fsd.normalizePath(EI)\
if\
fsd.testPerms(FZ,thread.getUID(coroutine.running()),\"r\")and\
fsd.testPerms(EI,thread.getUID(coroutine.running()),\"w\")then return true else return false,\
\"Access denied!\"end end\
function fsdf.move(M,LA)M=fsd.normalizePath(M)LA=fsd.normalizePath(LA)\
if\
fsd.testPerms(XK.getDir(M),thread.getUID(coroutine.running()),\"w\")and\
fsd.testPerms(XK.getDir(LA),thread.getUID(coroutine.running()),\"w\")then\
return true else return false,\"Access denied!\"end end\
function fsdf.delete(VI)VI=fsd.normalizePath(VI)\
if\
fsd.testPerms(XK.getDir(VI),thread.getUID(coroutine.running()),\"w\")then return true else return false,\"Access denied!\"end end\
function fsdf.open(SS,W)SS=fsd.normalizePath(SS)\
local BB={r=\"r\",rb=\"r\",w=\"w\",wb=\"w\",a=\"w\",ab=\"w\"}if not BB[W]then return false,\"Invalid mode!\"end\
if\
fsd.testPerms(SS,thread.getUID(coroutine.running()),BB[W])then return true else return false,\"Access denied!\"end end;local I=fs.open(kernel.root..\"/etc/fstab\",\"r\")\
for CM,R in\
pairs(string.split(I.readAll(),\"\\n\"))do local E=string.split(R,\" \")fsd.mount(E[1],E[3],E[2])end;I.close()if not J[\"/\"]then\
kernel.panic(\"Unable to mount root filesystem\")end;local O={}\
for JSF,H in pairs(XK)do\
fsd[JSF]=function(...)local OFC,ER;if fsdf[JSF]then\
OFC,ER=fsdf[JSF](unpack(arg))else OFC=true end\
if not OFC then error(ER)return false end;local N,R;if O[JSF]then\
N,R=fsd.getMount(fsd.resolveLinks(arg[1]))N,R=fsd.getMount(XK.getDir(R))else\
N,R=fsd.getMount(fsd.resolveLinks(arg[1]))end;local PR\
if\
getfenv()[N.fs]and getfenv()[N.fs][JSF]then\
PR=getfenv()[N.fs][JSF](R,fsd.normalizePath(N.dev),unpack(arg))else PR=XK[JSF](unpack(arg))end;return PR end end;fsd=applyreadonly(fsd)_G[\"fsd\"]=fsd",
  [ "/boot/uberkernel" ] = "\
KERNEL_DIR=fs.getDir(shell.getRunningProgram())local CRP=false;local QB=print;local M=write;local XJ=read;local N=error;local HU=fs\
local TA=coroutine.running()local LAK={}local LQ={}local S=nil;local FW=false;local KA={}local UF=false;os.unloadAPI(\"io\")\
argv={...}local H={}local MC=fs;local J=false;local I=false;local JW=false;local F=false;local W={}local VV={}local WL=nil\
function applyreadonly(HZG,T)\
local UR={}\
setmetatable(UR,{__index=HZG,__newindex=function(HZG,L,NWW)if thread then\
if\
thread.getUID(coroutine.running())~=0 then error(\"Attempt to modify read-only table\")end end end,__metatable=false})H[#H+1]=UR;return UR end;local IZ=rawset\
rawset=function(DD,E,VVZE)\
for i=1,#H do\
if(DD==H[i])or(DD[E]==H[i])then\
if thread then if\
thread.getUID(coroutine.running())~=0 then\
error(\"Attempt to modify read-only table\")end end;return end end;IZ(DD,E,VVZE)end\
local function SG()term.clear()term.setCursorPos(1,1)\
QB(\"Kernel debug console <CTRL>+T\")\
QB(\"Type 'exit' to leave, 'help' for available commands\")local AR=\"\"local UO={}\
while AR~=\"exit\"do M(\"> \")AR=XJ(nil,UO)\
if AR==\"exit\"then CRP=false;return end;if AR==\"help\"then\
QB(\"exit, help, reboot, shutdown, saferb, killbutinit, killall, kill, rbtocraftos, umountall, ps\")end;if AR==\"reboot\"then\
os.reboot()end;if AR==\"shutdown\"then os.shutdown()end;if\
AR==\"saferb\"then os.reboot()end\
if AR==\"killbutinit\"then LQ={}LAK={LAK[1]}end;if AR==\"killall\"then LQ={}LAK={}end\
if AR==\"rbtocraftos\"then\
fs.move(ROOT_DIR..\"/startup\",\
ROOT_DIR..\"/.startup_backup\")local FQ=fs.open(ROOT_DIR..\"/startup\",\"w\")\
FQ.write(\"ROOT_DIR=fs.getDir(shell.getRunningProgram())\\\
      fs.delete(ROOT_DIR .. '/startup')\\\
      fs.move(ROOT_DIR .. '/.startup_backup', ROOT_DIR .. '/startup')\\\
      print('Be careful! UberOS will start on next reboot!')\")FQ.close()os.reboot()end;if AR==\"umountall\"then QB(\"WIP\")end;if AR==\"ps\"then for NF,P in pairs(LAK)do\
QB(P.pid,\" \",P.desc,\" \",P.uid)end end\
if\
string.sub(AR,1,5)==\"kill \"then\
if#AR<=5 then QB(\"Usage: kill <PID>\")end;local QJ=tonumber(string.sub(AR,6,#AR))\
for E,FNB in pairs(LAK)do if FNB.pid==\
QJ then kernel.sendEvent(\"THREADDEAD\",QJ)\
table.remove(LAK,E)break end end end;table.insert(UO,AR)end;CRP=false end\
local G=function()kernel.log(\"Starting thread manager\")\
lua.include(\"copy\")thread={[\"kerneld\"]=0}\
local NE=function()return{isStdin=true}end;local SH=function()return{isStdout=true}end;local EN=function()\
return{isStderr=true}end\
rawset(thread,\"onPanic\",function(DK)if DK==TA then UF=true end end)\
rawset(thread,\"newPID\",function()if not FW then FW=true;return 1 end;local MP=true\
while true do\
local MW=math.random(2,32767)\
for i=1,#LAK do if LAK[i].pid==MW then MP=false;break end end;if MP then return MW end end end)\
rawset(thread,\"startThread\",function(UH,NV,P,PS,ZA,PV,GN,RE)if\
thread.getUID(coroutine.running())~=0 then RE=nil end;local PJ=thread.newPID()\
if not PS then PS=0 end;if not\
((PJ==1)or\
(PS==thread.getUID(coroutine.running()))or\
(0 ==thread.getUID(coroutine.running())))then\
PS=thread.getUID(coroutine.running())end\
table.insert(LQ,{cr=coroutine.create(UH),blockTerminate=\
NV or false,error=nil,dead=false,filter=nil,kill=0,pid=PJ,lastevent=kernel.getLastEvent(),ppid=thread.getPID(coroutine.running()),desc=\
P or\"\",uid=PS,stdin=ZA or NE(),stdout=PV or SH(),stderr=GN or EN(),daemon=RE})return PJ,LQ[#LQ]end)\
rawset(thread,\"runFile\",function(CX,V,B,DZ,E,SC,KE,GD)\
local HPT,QC=thread.startThread(function()shell.run(CX)end,V or true,GD or CX,DZ or\
thread.getUID(coroutine.running()),E,SC,KE,GD)if GD and\
(thread.getUID(coroutine.running())==0)then QC.ppid=1 end\
if B then while true do\
local VS,UH,SI,FOH,U,QT=kernel.pullEvent()\
if(VS==\"THREADDEAD\")and(UH==HPT)then return end end else return HPT end end)\
rawset(thread,\"runDaemon\",function(K,L)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot start daemon \"..L..\" - Access denied!\")return end;if KA[L]then\
kernel.log(\
\"Daemon \"..L..\" is already running.\")return end\
local X=thread.runFile(K,true,false,nil,nil,nil,nil,L)KA[L]=X\
fs.open(\"/var/lock/\"..L,\"w\").close()kernel.log(\"Daemon \"..L..\" started\")end)\
rawset(thread,\"stopDaemon\",function(HD)if\
thread.getUID(coroutine.running())~=0 then\
kernel.log(\"Cannot stop daemon \"..HD..\" - Access denied!\")return end;if not KA[HD]then\
kernel.log(\
\"Daemon \"..HD..\" is not running.\")return end;thread.kill(KA[HD],2)KA[HD]=\
nil;fs.delete(\"/var/lock/\"..HD)kernel.log(\"Daemon \"..\
HD..\" stopped\")end)\
rawset(thread,\"getDaemonStatus\",function(WH)if KA[WH]then return\"running\"else return\"stopped\"end end)\
rawset(thread,\"getLastEvent\",function(CD)if CD==0 then return 0 end\
local YO=thread.status(CD).lastEvent;if YO then return YO else return 0 end end)\
rawset(thread,\"setLastEvent\",function(Q,NQ)thread.status(Q).lastEvent=NQ end)\
rawset(thread,\"kill\",function(IS,FA)\
if IS==1 then kernel.log(\"Failed to kill init\")return end\
for i=1,#LAK do\
if LAK[i].pid==IS then\
if\
(LAK[i].uid==\
thread.getUID(coroutine.running()))or(\
thread.getUID(coroutine.running())==0)then LAK[i].kill=FA else\
kernel.log(\"Failed to kill process \"..IS..\" - Access Denied\")end end end end)\
rawset(thread,\"isKilled\",function(U)\
for i=1,#LAK do if LAK[i].cr==U then return LAK[i].kill end end\
for i=1,#LQ do if LQ[i].cr==U then return LQ[i].kill end end;return 0 end)\
rawset(thread,\"getPID\",function(KAX)\
for i=1,#LAK do if LAK[i].cr==KAX then return LAK[i].pid end end\
for i=1,#LQ do if LQ[i].cr==KAX then return LQ[i].pid end end;return 0 end)\
rawset(thread,\"getUID\",function(A)\
for i=1,#LAK do if LAK[i].cr==A then return LAK[i].uid end end\
for i=1,#LQ do if LQ[i].cr==A then return LQ[i].uid end end;return 0 end)\
rawset(thread,\"getRunningThreads\",function(FY)return LAK end)\
rawset(thread,\"status\",function(K)\
for i=1,#LAK do if LAK[i].pid==K then return LAK[i]end end;return nil end)local KR=print;local C=write;local WHC=read;local Y=error\
print=function(...)\
local CV=thread.status(thread.getPID(coroutine.running())).stdout;if CV.isStdout then KR(unpack(arg))else\
CV.writeLine(table.concat(arg,\"\"))end end\
write=function(XK)\
local V=thread.status(thread.getPID(coroutine.running())).stdout;if V.isStdout then C(XK)else V.write(XK)end end\
read=function(X,UQ)\
local CO=thread.status(thread.getPID(coroutine.running()))local GZQ=CO.stdin;local P\
if GZQ.isStdin then P=WHC(X,UQ)else P=GZQ.readLine()end;return P end\
error=function(SZT)SZT=SZT or\"\"if not SZT then N()return end\
local JF=thread.status(thread.getPID(coroutine.running()))local V=JF.stderr\
if not V.isStderr then V.write(SZT)Y()else if term.isColor()then\
term.setTextColor(colors.red)print(SZT)term.setTextColor(colors.white)N()else\
print(SZT)N()end end end\
local function YI(QT,RO,...)if CRP then SG()return end\
if UF then while true do coroutine.yield()end end;if QT.dead then return end\
if QT.filter~=nil and RO~=QT.filter then return end;if RO==\"terminate\"then return end\
coroutine.resume(QT.cr,RO,...)\
QT.dead=(coroutine.status(QT.cr)==\"dead\")\
if QT.dead and QT.pid~=1 then local CP=deepcopy(KA)\
for MR,E in pairs(KA)do if MR==QT.daemon then\
kernel.log(\
\"Daemon \"..QT.daemon..\" stopped\")CP[MR]=nil end end;KA=CP;kernel.sendEvent(\"THREADDEAD\",QT.pid)if not\
QT.stdout.isStdout then QT.stdout.close()end;if not\
QT.stdin.isStdin then QT.stdin.close()end;if not\
QT.stderr.isStderr then QT.stderr.close()end end end\
local function SO()if UF then while true do coroutine.yield()end end\
if\
#LQ>0 then local LU=LQ;LQ={}\
for ES,GY in ipairs(LU)do table.insert(LAK,GY)end;for O,X in ipairs(LU)do YI(X)end end;local T;if S then T={S(coroutine.yield())}else\
T={coroutine.yield()}end\
if T[1]==\"terminate\"then CRP=not CRP end;local MCK=nil\
for RS,II in ipairs(LAK)do YI(II,unpack(T))if II.dead then if MCK==nil then MCK={}end;table.insert(MCK,\
RS-#MCK)end end\
if MCK~=nil then for V,TK in ipairs(MCK)do table.remove(LAK,TK)end end end\
rawset(thread,\"setGlobalEventFilter\",function(A)\
if S~=nil then error(\"This can only be set once!\")end;S=A;rawset(thread,\"setGlobalEventFilter\",nil)end)thread=applyreadonly(thread)_G[\"thread\"]=thread\
_G=applyreadonly(_G,true)\
if type(threadMain)==\"function\"then\
thread.startThread(threadMain)else\
thread.startThread(function()kernel.log(\"Starting init\")\
shell.run(\"/sbin/init\")end,true,\"init\",uid)end;while#LAK>0 or#LQ>0 do SO()end\
kernel.log(\"Exiting thread manager\")end;local OY=os.pullEvent;local XA=os.pullEventRaw;kernel={}kernel.root=ROOT_DIR\
kernel.panic=function(Q)\
write(\
\"[\"..os.clock()..\"] Kernel panic: \".. (Q or\"\"))\
if JW then print(\" ... no panic is active! Contining...\")else LAK={}\
LQ={}while true do sleep(0)end end end\
kernel.log=function(JI)local MQ=\"[\"..os.clock()..\"] \"..JI;if not I then\
M(MQ..\"\\n\")end;local B\
if F then\
if MC.exists(ROOT_DIR..\"/var/log/kernel_log\")then B=MC.open(\
ROOT_DIR..\"/var/log/kernel_log\",\"a\")else B=MC.open(\
ROOT_DIR..\"/var/log/kernel_log\",\"w\")end;B.write(MQ..\"\\n\")B.close()end end\
kernel.loadModule=function(SI,A)for i=1,#VV do if VV[i]==SI then return true end end;kernel.log(\
\"Loading module \"..SI)status,err=pcall(shell.run,ROOT_DIR..\
\"/lib/modules/\"..SI)\
if status then\
kernel.log(\"Loading module DONE\")table.insert(VV,SI)return true else\
kernel.log(\"Loading module FAILED\")if A then\
kernel.panic(\"Failed to load module \"..SI..\"\\nError: \"..err)else\
error(\"Failed to load module\"..SI..\"\\nError: \"..err)end end end;kernel.getLastEvent=function()return#W end\
kernel.pullEvent=function()local JU=#W;while#W<=JU do\
JU=thread.getLastEvent(thread.getPID(coroutine.running()))sleep(0.05)end;thread.setLastEvent(thread.getPID(coroutine.running()),\
JU+1)\
return\
W[JU+1].event,W[JU+1].a,W[JU+1].b,W[JU+1].c,W[JU+1].d,W[JU+1].e end\
kernel.sendEvent=function(WY,A,TY,B,FG,LX)\
if WY==\"THREADDEAD\"then if coroutine.running()~=TA then\
kernel.log(\"Fake THREADDEAD event\")return false end end\
W[#W+1]={[\"event\"]=WY,[\"a\"]=A,[\"b\"]=TY,[\"c\"]=B,[\"d\"]=FG,[\"e\"]=LX}return true end;kernel.LISTMODULES=function()\
return fs.list(ROOT_DIR..\"/lib/modules\")end\
kernel.LISTFLAGS=function()return\
{\"Debug\",\"Silent\",\"NoPanic\",\"Log\"}end\
local function NZ()\
kernel.log(\"Boot directory = /\"..KERNEL_DIR)\
kernel.log(\"Root directory = /\"..ROOT_DIR)if\
fs.exists(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")then\
fs.delete(\"/\"..KERNEL_DIR..\"/var/log/kernel_log\")end\
if\
fs.exists(ROOT_DIR..\"/tmp\")and fs.isDir(ROOT_DIR..\"/tmp\")then for T,A in pairs(fs.list(ROOT_DIR..\
\"/tmp\"))do\
fs.delete(ROOT_DIR..\"/tmp/\"..A)end\
for KS,JCW in\
pairs(fs.list(ROOT_DIR..\"/var/lock\"))do fs.delete(ROOT_DIR..\"/tmp/\"..JCW)end end\
local HP=\".:\"..ROOT_DIR..\"/bin:\"..\
ROOT_DIR..\"/sbin:\"..ROOT_DIR..\"/etc/init.d\"shell.setPath(HP)shell.setPath=nil\
shell.setAlias(\"ls\",ROOT_DIR..\"/bin/ls\")shell.setAlias(\"cp\",ROOT_DIR..\"/bin/cp\")shell.setAlias(\"mv\",\
ROOT_DIR..\"/bin/mv\")shell.setAlias(\"rm\",ROOT_DIR..\
\"/bin/rm\")\
shell.setAlias(\"clr\",ROOT_DIR..\"/bin/clear\")shell.setAlias(\"sh\",ROOT_DIR..\"/bin/ush\")\
os.pullEventRaw=function(MOZ)\
if\
thread then local ZO=thread.isKilled(coroutine.running())if\
ZO>=2 then\
kernel.log(\"Killed process. PID = \"..thread.getPID(coroutine.running()))error()end;if ZO==1 then\
return\"terminate\"end end;return XA(MOZ)end;os.pullEvent=os.pullEventRaw;local HS\
if#argv<=1 then\
kernel.loadModule(\"lua\",true)HS=fs.list(ROOT_DIR..\"/lib/modules\")else HS={}\
for i=2,#argv do if\
string.sub(argv[i],1,1)==\"m\"then\
table.insert(HS,string.sub(argv[i],2,#argv[i]))end end end;for i=1,#HS do kernel.loadModule(HS[i],true)end;if fsd then\
fs=fsd;_G[\"fs\"]=_G[\"fsd\"]end;G()end;local function LF()os.pullEvent=OY;os.pullEventRaw=XA end\
kernel=applyreadonly(kernel)_G[\"kernel\"]=kernel;if#argv==0 then return end\
if argv[1]==\"start\"then\
if#argv>1 then\
for i=2,#\
argv do if argv[i]==\"fDebug\"then J=true end\
if argv[i]==\"fNoPanic\"then JW=true end;if argv[i]==\"fLog\"then F=true end\
if argv[i]==\"fSilent\"then I=true end end end;NZ()return end;if argv[1]==\"unload\"then LF()return end;if argv[1]==\"restart\"then\
os.reboot()end\
if argv[1]==\"stop\"then os.shutdown()end",
  [ "/PKGINFO.lua" ] = "DEPENDS = {\"corelib\"}\
VERSION = {0, 2, 1}",
  [ "/etc/init.d" ] = true,
  [ "/etc" ] = true,
  [ "/lib/modules" ] = true,
  [ "/etc/init.d/kerneld" ] = "argv={...}if#argv==0 then\
print(\"kerneld start|stop|restart|status\")return end;if argv[1]==\"status\"then\
print(thread.getDaemonStatus(\"kerneld\"))end;if argv[1]==\"start\"then\
shell.run(\"/boot/uberkernel start\")end;if argv[1]==\"stop\"then\
shell.run(\"/boot/uberkernel stop\")end;if argv[1]==\"restart\"then\
shell.run(\"/boot/uberkernel restart\")end",
}