{
  [ "/PKGINFO.lua" ] = "DEPENDS = {\"uberkernel\"}\
VERSION = {0, 2, 1}",
  [ "/lib/min.lua" ] = "lua.include('parselua')lua.include('util')\
local A=lua_parser.ParseLua;local AJ=util.lookupify\
local B=AJ{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\
local I=AJ{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}\
local EB=AJ{'0','1','2','3','4','5','6','7','8','9'}\
local YI=AJ{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}\
local function GE(SH)local OW,M;local Q=0\
local function ML(HZ,YF,O)if Q>150 then Q=0;return HZ..\"\\n\"..YF end;O=O or' 'local RO,J=HZ:sub(\
-1,-1),YF:sub(1,1)\
if I[RO]or B[RO]or RO=='_'then\
if not(I[J]or\
B[J]or J=='_'or EB[J])then\
return HZ..YF elseif J=='('then print(\"==============>>>\",RO,J)return HZ..O..YF else return\
HZ..O..YF end elseif EB[RO]then\
if J=='('then return HZ..YF elseif YI[J]then return HZ..YF else return HZ..O..YF end elseif RO==''then return HZ..YF else\
if J=='('then return HZ..O..YF else return HZ..YF end end end\
M=function(MP,RO)local RO=RO or 0;local UK=0;local KG=false;local C=\"\"\
if MP.AstType=='VarExpr'then if MP.Variable then C=C..\
MP.Variable.Name else C=C..MP.Name end elseif\
MP.AstType=='NumberExpr'then C=C..MP.Value.Data elseif MP.AstType=='StringExpr'then C=C..\
MP.Value.Data elseif MP.AstType=='BooleanExpr'then\
C=C..tostring(MP.Value)elseif MP.AstType=='NilExpr'then C=ML(C,\"nil\")elseif MP.AstType=='BinopExpr'then\
UK=MP.OperatorPrecedence;C=ML(C,M(MP.Lhs,UK))C=ML(C,MP.Op)\
C=ML(C,M(MP.Rhs))if MP.Op=='^'or MP.Op=='..'then UK=UK-1 end;if UK<RO then KG=false else\
KG=true end elseif MP.AstType=='UnopExpr'then C=ML(C,MP.Op)\
C=ML(C,M(MP.Rhs))elseif MP.AstType=='DotsExpr'then C=C..\"...\"elseif MP.AstType=='CallExpr'then\
C=C..M(MP.Base)C=C..\"(\"\
for i=1,#MP.Arguments do C=C..M(MP.Arguments[i])if i~=#\
MP.Arguments then C=C..\",\"end end;C=C..\")\"elseif MP.AstType=='TableCallExpr'then C=C..M(MP.Base)C=C..\
M(MP.Arguments[1])elseif MP.AstType=='StringCallExpr'then\
C=C..M(MP.Base)C=C..MP.Arguments[1].Data elseif MP.AstType=='IndexExpr'then\
C=C..\
M(MP.Base)..\"[\"..M(MP.Index)..\"]\"elseif MP.AstType=='MemberExpr'then C=C..\
M(MP.Base)..MP.Indexer..MP.Ident.Data elseif MP.AstType=='Function'then\
MP.scope:ObfuscateVariables()C=C..\"function(\"\
if#MP.Arguments>0 then\
for i=1,#MP.Arguments do C=C..\
MP.Arguments[i].Name;if i~=#MP.Arguments then C=C..\",\"elseif MP.VarArg then\
C=C..\",...\"end end elseif MP.VarArg then C=C..\"...\"end;C=C..\")\"C=ML(C,OW(MP.Body))C=ML(C,\"end\")elseif\
MP.AstType=='ConstructorExpr'then C=C..\"{\"\
for i=1,#MP.EntryList do local TU=MP.EntryList[i]\
if TU.Type=='Key'then\
C=C..\"[\"..\
M(TU.Key)..\"]=\"..M(TU.Value)elseif TU.Type=='Value'then C=C..M(TU.Value)elseif TU.Type=='KeyString'then C=C..TU.Key..\"=\"..\
M(TU.Value)end;if i~=#MP.EntryList then C=C..\",\"end end;C=C..\"}\"elseif MP.AstType=='Parentheses'then\
C=C..\"(\"..M(MP.Inner)..\")\"end;if not KG then\
C=string.rep('(',MP.ParenCount or 0)..C\
C=C..string.rep(')',MP.ParenCount or 0)end;Q=Q+#C;return C end\
local Z=function(C)local S=''\
if C.AstType=='AssignmentStatement'then for i=1,#C.Lhs do S=S..M(C.Lhs[i])if i~=#\
C.Lhs then S=S..\",\"end end\
if\
#C.Rhs>0 then S=S..\"=\"for i=1,#C.Rhs do S=S..M(C.Rhs[i])\
if i~=#C.Rhs then S=S..\",\"end end end elseif C.AstType=='CallStatement'then S=M(C.Expression)elseif\
C.AstType=='LocalStatement'then S=S..\"local \"\
for i=1,#C.LocalList do\
S=S..C.LocalList[i].Name;if i~=#C.LocalList then S=S..\",\"end end;if#C.InitList>0 then S=S..\"=\"\
for i=1,#C.InitList do\
S=S..M(C.InitList[i])if i~=#C.InitList then S=S..\",\"end end end elseif\
C.AstType=='IfStatement'then S=ML(\"if\",M(C.Clauses[1].Condition))\
S=ML(S,\"then\")S=ML(S,OW(C.Clauses[1].Body))\
for i=2,#C.Clauses do\
local J=C.Clauses[i]if J.Condition then S=ML(S,\"elseif\")S=ML(S,M(J.Condition))\
S=ML(S,\"then\")else S=ML(S,\"else\")end\
S=ML(S,OW(J.Body))end;S=ML(S,\"end\")elseif C.AstType=='WhileStatement'then\
S=ML(\"while\",M(C.Condition))S=ML(S,\"do\")S=ML(S,OW(C.Body))S=ML(S,\"end\")elseif\
C.AstType=='DoStatement'then S=ML(S,\"do\")S=ML(S,OW(C.Body))S=ML(S,\"end\")elseif\
C.AstType=='ReturnStatement'then S=\"return\"\
for i=1,#C.Arguments do S=ML(S,M(C.Arguments[i]))if i~=#\
C.Arguments then S=S..\",\"end end elseif C.AstType=='BreakStatement'then S=\"break\"elseif C.AstType=='RepeatStatement'then S=\"repeat\"\
S=ML(S,OW(C.Body))S=ML(S,\"until\")S=ML(S,M(C.Condition))elseif\
C.AstType=='Function'then C.scope:ObfuscateVariables()if C.IsLocal then S=\"local\"end\
S=ML(S,\"function \")\
if C.IsLocal then S=S..C.Name.Name else S=S..M(C.Name)end;S=S..\"(\"\
if#C.Arguments>0 then for i=1,#C.Arguments do\
S=S..C.Arguments[i].Name\
if i~=#C.Arguments then S=S..\",\"elseif C.VarArg then S=S..\",...\"end end elseif C.VarArg then\
S=S..\"...\"end;S=S..\")\"S=ML(S,OW(C.Body))S=ML(S,\"end\")elseif\
C.AstType=='GenericForStatement'then C.scope:ObfuscateVariables()S=\"for \"for i=1,#C.VariableList do S=S..\
C.VariableList[i].Name\
if i~=#C.VariableList then S=S..\",\"end end;S=S..\" in\"\
for i=1,#C.Generators do\
S=ML(S,M(C.Generators[i]))if i~=#C.Generators then S=ML(S,',')end end;S=ML(S,\"do\")S=ML(S,OW(C.Body))S=ML(S,\"end\")elseif C.AstType==\
'NumericForStatement'then S=\"for \"S=S..C.Variable.Name..\"=\"S=S..\
M(C.Start)..\",\"..M(C.End)if C.Step then S=S..\
\",\"..M(C.Step)end;S=ML(S,\"do\")\
S=ML(S,OW(C.Body))S=ML(S,\"end\")elseif C.AstType=='LabelStatement'then S=getIndentation()..\
\"::\"..C.Label..\"::\"elseif C.AstType=='GotoStatement'then S=\
getIndentation()..\"goto \"..C.Label elseif C.AstType=='Comment'then elseif\
C.AstType=='Eof'then else\
print(\"Unknown AST Type: \"..C.AstType)end;Q=Q+#S;return S end\
OW=function(KY)local U=''KY.scope:ObfuscateVariables()for XZ,CO in pairs(KY.Body)do\
U=ML(U,Z(CO),';')end;return U end;SH.scope:ObfuscateVariables()return OW(SH)end\
minify=function(US)local GG,IZ;GG,IZ=lua_parser.ParseLua(US)\
if GG then return GE(IZ)else return false end end",
  [ "/lib" ] = true,
  [ "/lib/parselua.lua" ] = "lua.include(\"util\")lua.include(\"scope\")\
local WZ=util.lookupify;local T=WZ{' ','\\n','\\t','\\r'}\
local H={['\\r']='\\\\r',['\\n']='\\\\n',['\\t']='\\\\t',['\"']='\\\\\"',[\"'\"]=\"\\\\'\"}\
local GF=WZ{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\
local R=WZ{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}\
local QO=WZ{'0','1','2','3','4','5','6','7','8','9'}\
local NW=WZ{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}\
local C=WZ{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}\
local XG=WZ{'and','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'}\
local function XL(JX)local JM={}\
local CDM,OM=pcall(function()local Q=1;local L=1;local K=1;local function U()local Y=JX:sub(Q,Q)\
if Y=='\\n'then K=1;L=L+1 else K=K+1 end;Q=Q+1;return Y end;local function AS(M)M=M or 0;return\
JX:sub(Q+M,Q+M)end\
local function AJ(F)local QQPS=AS()for i=1,#F do if QQPS==F:sub(i,i)then\
return U()end end end;local function QQ(G)\
return error(\">> :\"..L..\":\"..K..\": \"..G,0)end\
local function LA()local X=Q\
if AS()=='['then local VH=0;local PG=1;while AS(VH+1)=='='do VH=\
VH+1 end\
if AS(VH+1)=='['then for _=0,VH+1 do U()end;local JL=Q\
while true do if AS()==''then\
QQ(\
\"Expected `]\"..string.rep('=',VH)..\"]` near <eof>.\",3)end;local LQG=true\
if AS()==']'then for i=1,VH do if AS(i)~='='then\
LQG=false end end\
if AS(VH+1)~=']'then LQG=false end else\
if AS()=='['then local SN=true\
for i=1,VH do if AS(i)~='='then SN=false;break end end\
if AS(VH+1)=='['and SN then PG=PG+1;for i=1,(VH+2)do U()end end end;LQG=false end\
if LQG then PG=PG-1;if PG==0 then break else for i=1,VH+2 do U()end end else U()end end;local E=JX:sub(JL,Q-1)for i=0,VH+1 do U()end;local NO=JX:sub(X,Q-1)\
return E,NO else return nil end else return nil end end\
while true do local PI={}local NZ=''local OD=false\
while true do local ZL=AS()\
if\
ZL=='#'and AS(1)=='!'and L==1 then U()U()NZ=\"#!\"\
while AS()~='\\n'and AS()~=''do NZ=NZ..U()end\
local TUH={Type='Comment',CommentType='Shebang',Data=NZ,Line=L,Char=K}\
TUH.Print=function()\
return\"<\"..\
\
(TUH.Type..string.rep(' ',7-#TUH.Type))..\"  \".. (TUH.Data or'')..\" >\"end;NZ=\"\"table.insert(PI,TUH)end\
if ZL==' 'or ZL=='\\t'then local I=U()\
table.insert(PI,{Type='Whitespace',Line=L,Char=K,Data=I})elseif ZL=='\\n'or ZL=='\\r'then local O=U()\
if NZ~=\"\"then\
local HE={Type='Comment',CommentType=OD and'LongComment'or'Comment',Data=NZ,Line=L,Char=K}\
HE.Print=function()\
return\"<\"..\
\
(HE.Type..string.rep(' ',7-#HE.Type))..\"  \".. (HE.Data or'')..\" >\"end;table.insert(PI,HE)NZ=\"\"end\
table.insert(PI,{Type='Whitespace',Line=L,Char=K,Data=O})elseif ZL=='-'and AS(1)=='-'then U()U()NZ=NZ..'--'local QL,G=LA()\
if G then NZ=NZ..G;OD=true else while\
AS()~='\\n'and AS()~=''do NZ=NZ..U()end end else break end end\
if NZ~=\"\"then\
local ZE={Type='Comment',CommentType=OD and'LongComment'or'Com mnment',Data=NZ,Line=L,Char=K}\
ZE.Print=function()\
return\"<\"..\
\
(ZE.Type..string.rep(' ',7-#ZE.Type))..\"  \".. (ZE.Data or'')..\" >\"end;table.insert(PI,ZE)end;local RK=L;local N=K;local V=\":\"..L..\":\"..K..\":> \"local RF=AS()\
local CC=nil\
if RF==''then CC={Type='Eof'}elseif R[RF]or GF[RF]or RF=='_'then local DV=Q;repeat U()RF=AS()until\
not(\
R[RF]or GF[RF]or QO[RF]or RF=='_')local VO=JX:sub(DV,Q-1)if XG[VO]then\
CC={Type='Keyword',Data=VO}else CC={Type='Ident',Data=VO}end elseif QO[RF]or(AS()==\
'.'and QO[AS(1)])then local YG=Q\
if RF=='0'and\
AS(1)=='x'then U()U()while NW[AS()]do U()end;if AJ('Pp')then AJ('+-')\
while QO[AS()]do U()end end else while QO[AS()]do U()end;if AJ('.')then\
while QO[AS()]do U()end end\
if AJ('Ee')then AJ('+-')while QO[AS()]do U()end end end;CC={Type='Number',Data=JX:sub(YG,Q-1)}elseif\
RF=='\\''or RF=='\\\"'then local RZK=Q;local IL=U()local QA=Q\
while true do local RF=U()if RF=='\\\\'then U()elseif RF==IL then break elseif RF==''then\
QQ(\"Unfinished string near <eof>\")end end;local XX=JX:sub(QA,Q-2)local ZY=JX:sub(RZK,Q-1)\
CC={Type='String',Data=ZY,Constant=XX}elseif RF=='['then local LO,CRQ=LA()if CRQ then CC={Type='String',Data=CRQ,Constant=LO}else U()\
CC={Type='Symbol',Data='['}end elseif AJ('>=<')then if AJ('=')then\
CC={Type='Symbol',Data=RF..'='}else CC={Type='Symbol',Data=RF}end elseif\
AJ('~')then if AJ('=')then CC={Type='Symbol',Data='~='}else\
QQ(\"Unexpected symbol `~` in source.\",2)end elseif AJ('.')then if AJ('.')then if AJ('.')then\
CC={Type='Symbol',Data='...'}else CC={Type='Symbol',Data='..'}end else\
CC={Type='Symbol',Data='.'}end elseif AJ(':')then\
if\
AJ(':')then CC={Type='Symbol',Data='::'}else CC={Type='Symbol',Data=':'}end elseif C[RF]then U()CC={Type='Symbol',Data=RF}else local RIA,I=LA()if RIA then\
CC={Type='String',Data=I,Constant=RIA}else\
QQ(\"Unexpected Symbol `\"..RF..\"` in source.\",2)end end;CC.LeadingWhite=PI;CC.Line=RK;CC.Char=N\
CC.Print=function()\
return\"<\".. (CC.Type..\
string.rep(' ',7-#CC.Type))..\
\"  \".. (CC.Data or'')..\" >\"end;JM[#JM+1]=CC;if CC.Type=='Eof'then break end end end)if not CDM then return false,OM end;local OF={}local P={}local RS=1\
function OF:getp()return RS end;function OF:setp(DZ)RS=DZ end;function OF:getTokenList()return JM end\
function OF:Peek(PPH)PPH=PPH or 0;return JM[math.min(\
#JM,RS+PPH)]end;function OF:Get(DS)local NQ=JM[RS]RS=math.min(RS+1,#JM)if DS then\
table.insert(DS,NQ)end;return NQ end;function OF:Is(MI)return\
OF:Peek().Type==MI end\
function OF:Save()P[#P+1]=RS end;function OF:Commit()P[#P]=nil end\
function OF:Restore()RS=P[#P]P[#P]=nil end\
function OF:ConsumeSymbol(FH,A)local U=self:Peek()\
if U.Type=='Symbol'then\
if FH then if U.Data==FH then self:Get(A)return\
true else return nil end else self:Get(A)return U end else return nil end end\
function OF:ConsumeKeyword(Y,CK)local DD=self:Peek()if\
DD.Type=='Keyword'and DD.Data==Y then self:Get(CK)return true else return nil end end;function OF:IsKeyword(GC)local CS=OF:Peek()\
return CS.Type=='Keyword'and CS.Data==GC end\
function OF:IsSymbol(TR)local L=OF:Peek()return L.Type==\
'Symbol'and L.Data==TR end;function OF:IsEof()return OF:Peek().Type=='Eof'end;return true,\
OF end\
local function BO(ON)local WE,HCM\
if type(ON)~='table'then WE,HCM=XL(ON)else WE,HCM=true,ON end;if not WE then return false,HCM end\
local function QM(CR)local K=\">> :\"..\
HCM:Peek().Line..\":\"..HCM:Peek().Char..\
\": \"..CR..\"\\n\"local MG=0\
if\
type(ON)=='string'then\
for M in ON:gmatch(\"[^\\n]*\\n?\")do if M:sub(-1,-1)=='\\n'then\
M=M:sub(1,-2)end;MG=MG+1\
if MG==HCM:Peek().Line then K=K..\">> `\"..\
M:gsub('\\t','    ')..\"`\\n\"\
for i=1,HCM:Peek().Char\
do local QF=M:sub(i,i)if QF=='\\t'then K=K..'    'else K=K..' 'end end;K=K..\"   ^^^^\"break end end end;return K end;local WD=0;local E={'_','a','b','c','d'}\
local function O(Z)local VP=scope:new(Z)\
VP.RenameVars=VP.ObfuscateLocals;VP.ObfuscateVariables=VP.ObfuscateLocals\
VP.Print=function()return\"<scope>\"end;return VP end;local YB;local TC;local AH,B,HP,IE\
local function OJ(F,YJP)local N=O(F)if not HCM:ConsumeSymbol('(',YJP)then return false,\
QM(\"`(` expected.\")end;local WU={}local UH=false\
while not\
HCM:ConsumeSymbol(')',YJP)do\
if HCM:Is('Ident')then\
local BSH=N:CreateLocal(HCM:Get(YJP).Data)WU[#WU+1]=BSH;if not HCM:ConsumeSymbol(',',YJP)then\
if\
HCM:ConsumeSymbol(')',YJP)then break else return false,QM(\"`)` expected.\")end end elseif\
HCM:ConsumeSymbol('...',YJP)then UH=true\
if not HCM:ConsumeSymbol(')',YJP)then return false,\
QM(\"`...` must be the last argument of a function.\")end;break else return false,QM(\"Argument name or `...` expected\")end end;local WE,P=TC(N)if not WE then return false,P end\
if\
not HCM:ConsumeKeyword('end',YJP)then return false,QM(\"`end` expected after function body\")end;local BQ={}BQ.AstType='Function'BQ.scope=N;BQ.Arguments=WU;BQ.Body=P\
BQ.VarArg=UH;BQ.Tokens=YJP;return true,BQ end\
function HP(LN)local FJ={}\
if HCM:ConsumeSymbol('(',FJ)then local WE,DO=YB(LN)\
if not WE then return false,DO end;if not HCM:ConsumeSymbol(')',FJ)then\
return false,QM(\"`)` Expected.\")end\
if false then\
DO.ParenCount=(DO.ParenCount or 0)+1;return true,DO else local MM={}MM.AstType='Parentheses'MM.Inner=DO;MM.Tokens=FJ;return true,MM end elseif HCM:Is('Ident')then local JP=HCM:Get(FJ)local YJ=LN:GetLocal(JP.Data)\
if\
not YJ then YJ=LN:GetGlobal(JP.Data)\
if not YJ then\
YJ=LN:CreateGlobal(JP.Data)else YJ.References=YJ.References+1 end else YJ.References=YJ.References+1 end;local RHY={}RHY.AstType='VarExpr'RHY.Name=JP.Data;RHY.Variable=YJ\
RHY.Tokens=FJ;return true,RHY else return false,QM(\"primary expression expected\")end end\
function IE(BX,Z)local WE,G=HP(BX)if not WE then return false,G end\
while true do local JW={}\
if HCM:IsSymbol('.')or\
HCM:IsSymbol(':')then local KQ=HCM:Get(JW).Data\
if\
not HCM:Is('Ident')then return false,QM(\"<Ident> expected.\")end;local HN=HCM:Get(JW)local DA={}DA.AstType='MemberExpr'DA.Base=G;DA.Indexer=KQ\
DA.Ident=HN;DA.Tokens=JW;G=DA elseif not Z and HCM:ConsumeSymbol('[',JW)then\
local WE,ZG=YB(BX)if not WE then return false,ZG end;if not HCM:ConsumeSymbol(']',JW)then return false,\
QM(\"`]` expected.\")end;local XK={}\
XK.AstType='IndexExpr'XK.Base=G;XK.Index=ZG;XK.Tokens=JW;G=XK elseif\
not Z and HCM:ConsumeSymbol('(',JW)then local HL={}\
while not HCM:ConsumeSymbol(')',JW)do local WE,F=YB(BX)\
if not WE then return false,F end;HL[#HL+1]=F;if not HCM:ConsumeSymbol(',',JW)then\
if\
HCM:ConsumeSymbol(')',JW)then break else return false,QM(\"`)` Expected.\")end end end;local A={}A.AstType='CallExpr'A.Base=G;A.Arguments=HL;A.Tokens=JW;G=A elseif not Z and\
HCM:Is('String')then local JB={}JB.AstType='StringCallExpr'JB.Base=G\
JB.Arguments={HCM:Get(JW)}JB.Tokens=JW;G=JB elseif not Z and HCM:IsSymbol('{')then local WE,VL=AH(BX)if not WE then\
return false,VL end;local JJ={}JJ.AstType='TableCallExpr'JJ.Base=G\
JJ.Arguments={VL}JJ.Tokens=JW;G=JJ else break end end;return true,G end\
function AH(OC)local EN={}\
if HCM:Is('Number')then local IP={}IP.AstType='NumberExpr'\
IP.Value=HCM:Get(EN)IP.Tokens=EN;return true,IP elseif HCM:Is('String')then local RG={}RG.AstType='StringExpr'\
RG.Value=HCM:Get(EN)RG.Tokens=EN;return true,RG elseif HCM:ConsumeKeyword('nil',EN)then local GZ={}\
GZ.AstType='NilExpr'GZ.Tokens=EN;return true,GZ elseif\
HCM:IsKeyword('false')or HCM:IsKeyword('true')then local US={}US.AstType='BooleanExpr'\
US.Value=(HCM:Get(EN).Data=='true')US.Tokens=EN;return true,US elseif HCM:ConsumeSymbol('...',EN)then local KR={}\
KR.AstType='DotsExpr'KR.Tokens=EN;return true,KR elseif HCM:ConsumeSymbol('{',EN)then local W={}\
W.AstType='ConstructorExpr'W.EntryList={}\
while true do\
if HCM:IsSymbol('[',EN)then HCM:Get(EN)local WE,CZ=YB(OC)if not WE then return false,\
QM(\"Key Expression Expected\")end\
if not\
HCM:ConsumeSymbol(']',EN)then return false,QM(\"`]` Expected\")end\
if not HCM:ConsumeSymbol('=',EN)then return false,QM(\"`=` Expected\")end;local WE,JC=YB(OC)\
if not WE then return false,QM(\"Value Expression Expected\")end\
W.EntryList[#W.EntryList+1]={Type='Key',Key=CZ,Value=JC}elseif HCM:Is('Ident')then local AI=HCM:Peek(1)\
if\
AI.Type=='Symbol'and AI.Data=='='then local CLF=HCM:Get(EN)if not HCM:ConsumeSymbol('=',EN)then return false,\
QM(\"`=` Expected\")end;local WE,BUU=YB(OC)if not WE then return false,\
QM(\"Value Expression Expected\")end\
W.EntryList[#W.EntryList+1]={Type='KeyString',Key=CLF.Data,Value=BUU}else local WE,ZU=YB(OC)\
if not WE then return false,QM(\"Value Exected\")end\
W.EntryList[#W.EntryList+1]={Type='Value',Value=ZU}end elseif HCM:ConsumeSymbol('}',EN)then break else local WE,G=YB(OC)\
W.EntryList[#W.EntryList+1]={Type='Value',Value=G}if not WE then return false,QM(\"Value Expected\")end end\
if\
HCM:ConsumeSymbol(';',EN)or HCM:ConsumeSymbol(',',EN)then elseif HCM:ConsumeSymbol('}',EN)then break else\
return false,QM(\"`}` or table entry Expected\")end end;W.Tokens=EN;return true,W elseif HCM:ConsumeKeyword('function',EN)then local WE,HW=OJ(OC,EN)if not WE then return\
false,HW end;HW.IsLocal=true;return true,HW else return IE(OC)end end;local KH=WZ{'-','not','#'}local Y=8\
local CXI={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}\
function B(BK,WS)local WE,JS\
if KH[HCM:Peek().Data]then local CM={}local LW=HCM:Get(CM).Data\
WE,JS=B(BK,Y)if not WE then return false,JS end;local BIN={}BIN.AstType='UnopExpr'BIN.Rhs=JS\
BIN.Op=LW;BIN.OperatorPrecedence=Y;BIN.Tokens=CM;JS=BIN else WE,JS=AH(BK)\
if not WE then return false,JS end end\
while true do local NWCZ=CXI[HCM:Peek().Data]\
if NWCZ and NWCZ[1]>WS then\
local M={}local F=HCM:Get(M).Data;local WE,NWTE=B(BK,NWCZ[2])\
if not WE then return false,NWTE end;local KK={}KK.AstType='BinopExpr'KK.Lhs=JS;KK.Op=F\
KK.OperatorPrecedence=NWCZ[1]KK.Rhs=NWTE;KK.Tokens=M;JS=KK else break end end;return true,JS end;YB=function(M)return B(M,0)end\
local function YQC(OJFO)local OY=nil;local UEO={}\
if\
HCM:ConsumeKeyword('if',UEO)then local XU={}XU.AstType='IfStatement'XU.Clauses={}\
repeat local WE,JZ=YB(OJFO)if not WE then\
return false,JZ end;if not HCM:ConsumeKeyword('then',UEO)then return false,\
QM(\"`then` expected.\")end\
local WE,TL=TC(OJFO)if not WE then return false,TL end\
XU.Clauses[#XU.Clauses+1]={Condition=JZ,Body=TL}until not HCM:ConsumeKeyword('elseif',UEO)\
if HCM:ConsumeKeyword('else',UEO)then local WE,KL=TC(OJFO)\
if not WE then return false,KL end;XU.Clauses[#XU.Clauses+1]={Body=KL}end;if not HCM:ConsumeKeyword('end',UEO)then\
return false,QM(\"`end` expected.\")end;XU.Tokens=UEO;OY=XU elseif\
HCM:ConsumeKeyword('while',UEO)then local KJ={}KJ.AstType='WhileStatement'local WE,Q=YB(OJFO)\
if not WE then return false,Q end;if not HCM:ConsumeKeyword('do',UEO)then\
return false,QM(\"`do` expected.\")end;local WE,YL=TC(OJFO)\
if not WE then return false,YL end;if not HCM:ConsumeKeyword('end',UEO)then\
return false,QM(\"`end` expected.\")end;KJ.Condition=Q;KJ.Body=YL\
KJ.Tokens=UEO;OY=KJ elseif HCM:ConsumeKeyword('do',UEO)then local WE,L=TC(OJFO)\
if not WE then return false,L end;if not HCM:ConsumeKeyword('end',UEO)then\
return false,QM(\"`end` expected.\")end;local DHM={}DHM.AstType='DoStatement'\
DHM.Body=L;DHM.Tokens=UEO;OY=DHM elseif HCM:ConsumeKeyword('for',UEO)then if not HCM:Is('Ident')then return\
false,QM(\"<ident> expected.\")end\
local Z=HCM:Get(UEO)\
if HCM:ConsumeSymbol('=',UEO)then local F=O(OJFO)\
local DHVI=F:CreateLocal(Z.Data)local WE,YR=YB(OJFO)if not WE then return false,YR end;if\
not HCM:ConsumeSymbol(',',UEO)then return false,QM(\"`,` Expected\")end\
local WE,US=YB(OJFO)if not WE then return false,US end;local WE,HZ;if HCM:ConsumeSymbol(',',UEO)then\
WE,HZ=YB(OJFO)if not WE then return false,HZ end end\
if not\
HCM:ConsumeKeyword('do',UEO)then return false,QM(\"`do` expected\")end;local WE,FJ=TC(F)if not WE then return false,FJ end\
if\
not HCM:ConsumeKeyword('end',UEO)then return false,QM(\"`end` expected\")end;local FM={}FM.AstType='NumericForStatement'FM.scope=F;FM.Variable=DHVI\
FM.Start=YR;FM.End=US;FM.Step=HZ;FM.Body=FJ;FM.Tokens=UEO;OY=FM else local TY=O(OJFO)\
local TYB={TY:CreateLocal(Z.Data)}\
while HCM:ConsumeSymbol(',',UEO)do if not HCM:Is('Ident')then return false,\
QM(\"for variable expected.\")end\
TYB[#TYB+1]=TY:CreateLocal(HCM:Get(UEO).Data)end;if not HCM:ConsumeKeyword('in',UEO)then\
return false,QM(\"`in` expected.\")end;local UN={}local WE,X=YB(OJFO)\
if not WE then return false,X end;UN[#UN+1]=X;while HCM:ConsumeSymbol(',',UEO)do local WE,CQ=YB(OJFO)\
if not WE then return false,CQ end;UN[#UN+1]=CQ end\
if not\
HCM:ConsumeKeyword('do',UEO)then return false,QM(\"`do` expected.\")end;local WE,K=TC(TY)if not WE then return false,K end\
if\
not HCM:ConsumeKeyword('end',UEO)then return false,QM(\"`end` expected.\")end;local YVR={}YVR.AstType='GenericForStatement'YVR.scope=TY;YVR.VariableList=TYB\
YVR.Generators=UN;YVR.Body=K;YVR.Tokens=UEO;OY=YVR end elseif HCM:ConsumeKeyword('repeat',UEO)then local WE,FM=TC(OJFO)\
if not WE then return false,FM end;if not HCM:ConsumeKeyword('until',UEO)then\
return false,QM(\"`until` expected.\")end;local WE,I=YB(FM.scope)if not WE then\
return false,I end;local MR={}MR.AstType='RepeatStatement'MR.Condition=I\
MR.Body=FM;MR.Tokens=UEO;OY=MR elseif HCM:ConsumeKeyword('function',UEO)then\
if\
not HCM:Is('Ident')then return false,QM(\"Function name expected\")end;local WE,YJK=IE(OJFO,true)if not WE then return false,YJK end\
local WE,SK=OJ(OJFO,UEO)if not WE then return false,SK end;SK.IsLocal=false;SK.Name=YJK;OY=SK elseif\
HCM:ConsumeKeyword('local',UEO)then\
if HCM:Is('Ident')then local A={HCM:Get(UEO).Data}while\
HCM:ConsumeSymbol(',',UEO)do if not HCM:Is('Ident')then\
return false,QM(\"local var name expected\")end\
A[#A+1]=HCM:Get(UEO).Data end;local QQ={}\
if\
HCM:ConsumeSymbol('=',UEO)then repeat local WE,HFB=YB(OJFO)if not WE then return false,HFB end;QQ[#QQ+1]=HFB until not\
HCM:ConsumeSymbol(',',UEO)end;for WY,XD in pairs(A)do A[WY]=OJFO:CreateLocal(XD)end\
local Z={}Z.AstType='LocalStatement'Z.LocalList=A;Z.InitList=QQ;Z.Tokens=UEO;OY=Z elseif\
HCM:ConsumeKeyword('function',UEO)then\
if not HCM:Is('Ident')then return false,QM(\"Function name expected\")end;local PK=HCM:Get(UEO).Data;local P=OJFO:CreateLocal(PK)\
local WE,QP=OJ(OJFO,UEO)if not WE then return false,QP end;QP.Name=P;QP.IsLocal=true;OY=QP else return false,\
QM(\"local var or function def expected\")end elseif HCM:ConsumeSymbol('::',UEO)then if not HCM:Is('Ident')then return false,\
QM('Label name expected')end\
local PP=HCM:Get(UEO).Data;if not HCM:ConsumeSymbol('::',UEO)then\
return false,QM(\"`::` expected\")end;local XN={}XN.AstType='LabelStatement'\
XN.Label=PP;XN.Tokens=UEO;OY=XN elseif HCM:ConsumeKeyword('return',UEO)then local A={}\
if not\
HCM:IsKeyword('end')then local WE,V=YB(OJFO)if WE then A[1]=V\
while HCM:ConsumeSymbol(',',UEO)do\
local WE,ZJ=YB(OJFO)if not WE then return false,ZJ end;A[#A+1]=ZJ end end end;local RKX={}RKX.AstType='ReturnStatement'RKX.Arguments=A;RKX.Tokens=UEO;OY=RKX elseif\
HCM:ConsumeKeyword('break',UEO)then local J={}J.AstType='BreakStatement'J.Tokens=UEO;OY=J elseif\
HCM:ConsumeKeyword('goto',UEO)then\
if not HCM:Is('Ident')then return false,QM(\"Label expected\")end;local A=HCM:Get(UEO).Data;local OC={}OC.AstType='GotoStatement'\
OC.Label=A;OC.Tokens=UEO;OY=OC else local WE,VG=IE(OJFO)if not WE then return false,VG end\
if\
HCM:IsSymbol(',')or HCM:IsSymbol('=')then if(VG.ParenCount or 0)>0 then\
return\
false,QM(\"Can not assign to parenthesized expression, is not an lvalue\")end;local OX={VG}\
while\
HCM:ConsumeSymbol(',',UEO)do local WE,F=IE(OJFO)if not WE then return false,F end;OX[#OX+1]=F end;if not HCM:ConsumeSymbol('=',UEO)then\
return false,QM(\"`=` Expected.\")end;local S={}local WE,X=YB(OJFO)\
if not WE then return false,X end;S[1]=X;while HCM:ConsumeSymbol(',',UEO)do local WE,V=YB(OJFO)\
if not WE then return false,V end;S[#S+1]=V end;local Z={}\
Z.AstType='AssignmentStatement'Z.Lhs=OX;Z.Rhs=S;Z.Tokens=UEO;OY=Z elseif\
VG.AstType=='CallExpr'or\
VG.AstType=='TableCallExpr'or VG.AstType=='StringCallExpr'then local VU={}VU.AstType='CallStatement'VU.Expression=VG;VU.Tokens=UEO;OY=VU else return false,\
QM(\"Assignment Statement Expected\")end end\
if HCM:IsSymbol(';')then OY.Semicolon=HCM:Get(OY.Tokens)end;return true,OY end;local DH=WZ{'end','else','elseif','until'}\
TC=function(HB)local DM={}\
DM.scope=O(HB)DM.AstType='Statlist'DM.Body={}DM.Tokens={}\
while\
not DH[HCM:Peek().Data]and not HCM:IsEof()do local WE,AJ=YQC(DM.scope)if not WE then\
return false,AJ end;DM.Body[#DM.Body+1]=AJ end\
if HCM:IsEof()then local QZ={}QZ.AstType='Eof'QZ.Tokens={HCM:Get()}DM.Body[\
#DM.Body+1]=QZ end;return true,DM end;local function U()local RW=O()return TC(RW)end;local WE,JV=U()return WE,JV end;lua_parser={LexLua=XL,ParseLua=BO}",
  [ "/lib/util.lua" ] = "\
local function Y(I)for NR,LR in pairs(I)do I[LR]=true end;return I end\
local function MY(RE)local PP=0;for I in pairs(RE)do PP=PP+1 end;return PP end\
local function D(SZ,G)if SZ.Print then return SZ.Print()end;G=G or 0;local Q=(MY(SZ)>1)local WA=string.rep('    ',\
G+1)\
local E=\"{\".. (Q and'\\n'or'')\
for F,AA in pairs(SZ)do\
if type(AA)~='function'then E=E.. (Q and WA or'')\
if\
type(F)=='number'then elseif\
type(F)=='string'and F:match(\"^[A-Za-z_][A-Za-z0-9_]*$\")then E=E..F..\" = \"elseif type(F)=='string'then\
E=E..\"[\\\"\"..F..\"\\\"] = \"else E=E..\"[\"..tostring(F)..\"] = \"end\
if type(AA)=='string'then E=E..\"\\\"\"..AA..\"\\\"\"elseif type(AA)=='number'then E=\
E..AA elseif type(AA)=='table'then\
E=E..D(AA,G+ (Q and 1 or 0))else E=E..tostring(AA)end;if next(SZ,F)then E=E..\",\"end;if Q then E=E..'\\n'end end end;E=E..\
(Q and string.rep('    ',G)or'')..\"}\"return E end\
local function A(NV)\
if NV:match(\"\\n\")then local T={}\
for RM in NV:gmatch(\"[^\\n]*\")do table.insert(T,RM)end;assert(#T>0)return T else return{NV}end end\
local function QV(VC,...)return print(string.format(VC,...))end\
util=applyreadonly({PrintTable=D,CountTable=MY,lookupify=Y,splitLines=A,printf=QV})",
  [ "/lib/scope.lua" ] = "\
local PW={new=function(JO,T)\
local DC={Parent=T,Locals={},Globals={},oldLocalNamesMap={},oldGlobalNamesMap={},Children={}}if T then table.insert(T.Children,DC)end;return\
setmetatable(DC,{__index=JO})end,AddLocal=function(SD,N)\
table.insert(SD.Locals,N)end,AddGlobal=function(JX,G)table.insert(JX.Globals,G)end,CreateLocal=function(H,IF)\
local VF;VF=H:GetLocal(IF)if VF then return VF end;VF={}VF.Scope=H;VF.Name=IF\
VF.IsGlobal=false;VF.CanRename=true;VF.References=1;H:AddLocal(VF)return VF end,GetLocal=function(N,WJ)for M,F in\
pairs(N.Locals)do if F.Name==WJ then return F end end;if N.Parent then return\
N.Parent:GetLocal(WJ)end end,GetOldLocal=function(P,TX)if\
P.oldLocalNamesMap[TX]then return P.oldLocalNamesMap[TX]end;return\
P:GetLocal(TX)end,mapLocal=function(E,L,JG)\
E.oldLocalNamesMap[L]=JG end,GetOldGlobal=function(O,HA)if O.oldGlobalNamesMap[HA]then\
return O.oldGlobalNamesMap[HA]end;return O:GetGlobal(HA)end,mapGlobal=function(X,QJ,A)\
X.oldGlobalNamesMap[QJ]=A end,GetOldVariable=function(S,NN)return\
S:GetOldLocal(NN)or S:GetOldGlobal(NN)end,RenameLocal=function(J,UE,T)UE=type(UE)=='string'and\
UE or UE.Name;local FV=false\
local MR=J:GetLocal(UE)if MR then MR.Name=T;J:mapLocal(UE,MR)FV=true end;if\
not FV and J.Parent then J.Parent:RenameLocal(UE,T)end end,RenameGlobal=function(WU,O,S)O=\
type(O)=='string'and O or O.Name;local VU=false\
local YK=WU:GetGlobal(O)if YK then YK.Name=S;WU:mapGlobal(O,YK)VU=true end\
if not VU and\
WU.Parent then WU.Parent:RenameGlobal(O,S)end end,RenameVariable=function(A,E,U)E=\
type(E)=='string'and E or E.Name;if A:GetLocal(E)then\
A:RenameLocal(E,U)else A:RenameGlobal(E,U)end end,GetAllVariables=function(CF)\
local AM=CF:getVars(true)\
for GF,AX in pairs(CF:getVars(false))do table.insert(AM,AX)end;return AM end,getVars=function(PH,GQ)local V={}\
if GQ then for XE,X in\
pairs(PH.Children)do\
for I,CH in pairs(X:getVars(true))do table.insert(V,CH)end end else for VZ,U in pairs(PH.Locals)do\
table.insert(V,U)end\
for YO,X in pairs(PH.Globals)do table.insert(V,X)end\
if PH.Parent then for C,E in pairs(PH.Parent:getVars(false))do\
table.insert(V,E)end end end;return V end,CreateGlobal=function(MH,Q)\
local O;O=MH:GetGlobal(Q)if O then return O end;O={}O.Scope=MH;O.Name=Q\
O.IsGlobal=true;O.CanRename=true;O.References=1;MH:AddGlobal(O)return O end,GetGlobal=function(JJ,U)for WL,EX in\
pairs(JJ.Globals)do if EX.Name==U then return EX end end;if JJ.Parent then return\
JJ.Parent:GetGlobal(U)end end,GetVariable=function(NK,Q)return\
NK:GetLocal(Q)or NK:GetGlobal(Q)end,ObfuscateLocals=function(GO,G,XC)\
G=1;local NE=XC or\"QWERTYUIOPASDFGHJKLZXCVBNM\"\
local Z=XC or\"QWERTYUIOPASDFGHJKLZXCVBNM\"\
for E,PWL in pairs(GO.Locals)do local GU=\"\"local XV=0\
repeat local H=math.random(1,#NE)\
GU=GU..NE:sub(H,H)for i=1,math.random(0,XV>5 and 30 or G)do local H=math.random(1,#Z)GU=GU..\
Z:sub(H,H)end;XV=XV+1 until not\
GO:GetVariable(GU)GO:RenameLocal(PWL.Name,GU)end end}scope=PW",
}