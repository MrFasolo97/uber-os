{
  [ "/PKGINFO.lua" ] = "DEPENDS = {\"uberkernel\"}\
VERSION = {0, 2, 1}",
  [ "/lib/libjson.lua" ] = "local V=20140923;local A={VERSION=V}\
local HH={__tostring=function()return\"JSON array\"end}HH.__index=HH\
local LU={__tostring=function()return\"JSON object\"end}LU.__index=LU\
function A:newArray(N)return setmetatable(N or{},HH)end;function A:newObject(Y)return setmetatable(Y or{},LU)end\
local function U(H)\
if\
H<=127 then return string.char(H)elseif H<=2047 then local XY=math.floor(H/0x40)local OH=H-\
(0x40*XY)return string.char(0xC0+XY,0x80+OH)elseif\
H<=65535 then local MB=math.floor(H/0x1000)local W=H-0x1000*MB\
local G=math.floor(W/0x40)local WO=W-0x40*G;MB=0xE0+MB;G=0x80+G;WO=0x80+WO\
if\
\
(MB==0xE0 and G<0xA0)or(MB==0xED and G>0x9F)or\
(MB==0xF0 and G<0x90)or(MB==0xF4 and G>0x8F)then return\"?\"else return string.char(MB,G,WO)end else local N=math.floor(H/0x40000)local VNA=H-0x40000*N;local G=math.floor(VNA/\
0x1000)VNA=VNA-0x1000*G\
local UX=math.floor(VNA/0x40)local FG=VNA-0x40*UX;return\
string.char(0xF0+N,0x80+G,0x80+UX,0x80+FG)end end\
function A:onDecodeError(LI,CP,M,AUQ)if AUQ~=nil then\
LI=LI..\" (\"..A:encode(AUQ)..\")\"end;if self.assert then self.assert(false,LI)else\
assert(false,LI)end end;A.onDecodeOfNilError=A.onDecodeError;A.onDecodeOfHTMLError=A.onDecodeError;function A:onEncodeError(B,HI)\
if\
HI~=nil then B=B..\" (\"..A:encode(HI)..\")\"end\
if self.assert then self.assert(false,B)else assert(false,B)end end\
local function GI(P,K,KNH,CW)local UZD=\
K:match('^-?[1-9]%d*',KNH)or K:match(\"^-?0\",KNH)\
if\
not UZD then P:onDecodeError(\"expected number\",K,KNH,CW)end;local PJ=KNH+UZD:len()\
local ZHX=K:match('^%.%d+',PJ)or\"\"PJ=PJ+ZHX:len()\
local VB=K:match('^[eE][-+]?%d+',PJ)or\"\"PJ=PJ+VB:len()local B=UZD..ZHX..VB;local FS=tonumber(B)if not FS then\
P:onDecodeError(\"bad number\",K,KNH,CW)end;return FS,PJ end\
local function Z(Q,YA,RI,VC)if YA:sub(RI,RI)~='\"'then\
Q:onDecodeError(\"expected string's opening quote\",YA,RI,VC)end;local LZ=RI+1;local P=YA:len()\
local YO=\"\"\
while LZ<=P do local DO=YA:sub(LZ,LZ)if DO=='\"'then return YO,LZ+1 end\
if DO~='\\\\'then\
YO=YO..DO;LZ=LZ+1 elseif YA:match('^\\\\b',LZ)then YO=YO..\"\\b\"LZ=LZ+2 elseif YA:match('^\\\\f',LZ)then\
YO=YO..\"\\f\"LZ=LZ+2 elseif YA:match('^\\\\n',LZ)then YO=YO..\"\\n\"LZ=LZ+2 elseif YA:match('^\\\\r',LZ)then\
YO=YO..\"\\r\"LZ=LZ+2 elseif YA:match('^\\\\t',LZ)then YO=YO..\"\\t\"LZ=LZ+2 else\
local JH=YA:match('^\\\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])',LZ)\
if JH then LZ=LZ+6;local O=tonumber(JH,16)\
if O>=0xD800 and O<=0xDBFF then\
local YN=YA:match('^\\\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])',LZ)if YN then LZ=LZ+6\
O=0x2400+ (O-0xD800)*0x400+tonumber(YN,16)else end end;YO=YO..U(O)else YO=YO..YA:match('^\\\\(.)',LZ)LZ=LZ+2 end end end;Q:onDecodeError(\"unclosed string\",YA,RI,VC)end\
local function ED(T,E)local AK,TX=T:find(\"^[ \\n\\r\\t]+\",E)if TX then return TX+1 else return E end end;local L\
local function GD(AT,JR,JU,NN)if JR:sub(JU,JU)~='{'then\
AT:onDecodeError(\"expected '{'\",JR,JU,NN)end;local QP=ED(JR,JU+1)local E=AT.strictTypes and\
AT:newObject{}or{}if\
JR:sub(QP,QP)=='}'then return E,QP+1 end;local DC=JR:len()\
while QP<=DC do\
local J,B=Z(AT,JR,QP,NN)QP=ED(JR,B)if JR:sub(QP,QP)~=':'then\
AT:onDecodeError(\"expected colon\",JR,QP,NN)end;QP=ED(JR,QP+1)local G,B=L(AT,JR,QP)\
E[J]=G;QP=ED(JR,B)local RK=JR:sub(QP,QP)if RK=='}'then return E,QP+1 end;if\
JR:sub(QP,QP)~=','then\
AT:onDecodeError(\"expected comma or '}'\",JR,QP,NN)end;QP=ED(JR,QP+1)end;AT:onDecodeError(\"unclosed '{'\",JR,JU,NN)end\
local function IJ(OX,TQ,M,KE)if TQ:sub(M,M)~='['then\
OX:onDecodeError(\"expected '['\",TQ,M,KE)end;local TE=ED(TQ,M+1)local WK=\
OX.strictTypes and OX:newArray{}or{}if TQ:sub(TE,TE)==']'then\
return WK,TE+1 end;local XP=1;local LUNK=TQ:len()\
while TE<=LUNK do local OJ,RN=L(OX,TQ,TE)\
WK[XP]=OJ;XP=XP+1;TE=ED(TQ,RN)local K=TQ:sub(TE,TE)\
if K==']'then return WK,TE+1 end;if TQ:sub(TE,TE)~=','then\
OX:onDecodeError(\"expected comma or '['\",TQ,TE,KE)end;TE=ED(TQ,TE+1)end;OX:onDecodeError(\"unclosed '['\",TQ,M,KE)end\
L=function(T,J,JGP,WN)JGP=ED(J,JGP)if JGP>J:len()then\
T:onDecodeError(\"unexpected end of string\",J,nil,WN)end\
if J:find('^\"',JGP)then return Z(T,J,JGP,WN)elseif\
J:find('^[-0123456789 ]',JGP)then return GI(T,J,JGP,WN)elseif J:find('^%{',JGP)then return GD(T,J,JGP,WN)elseif\
J:find('^%[',JGP)then return IJ(T,J,JGP,WN)elseif J:find('^true',JGP)then return true,JGP+4 elseif J:find('^false',JGP)then return\
false,JGP+5 elseif J:find('^null',JGP)then return nil,JGP+4 else\
T:onDecodeError(\"can't parse JSON\",J,JGP,WN)end end\
function A:decode(WD,CZ)if type(self)~='table'or self.__index~=A then\
A:onDecodeError(\"JSON:decode must be called in method format\",\
nil,nil,CZ)end\
if WD==nil then\
self:onDecodeOfNilError(string.format(\"nil passed to JSON:decode()\"),\
nil,nil,CZ)elseif type(WD)~='string'then\
self:onDecodeError(string.format(\"expected string argument to JSON:decode(), got %s\",type(WD)),\
nil,nil,CZ)end;if WD:match('^%s*$')then return nil end;if WD:match('^%s*<')then\
self:onDecodeOfHTMLError(string.format(\"html passed to JSON:decode()\"),WD,\
nil,CZ)end;if\
WD:sub(1,1):byte()==0 or\
(WD:len()>=2 and WD:sub(2,2):byte()==0)then\
self:onDecodeError(\"JSON package groks only UTF-8, sorry\",WD,nil,CZ)end\
local XP,T=pcall(L,self,WD,1,CZ)if XP then return T else\
if self.assert then self.assert(false,T)else assert(false,T)end;return nil,T end end\
local function YE(LM)\
if LM==\"\\n\"then return\"\\\\n\"elseif LM==\"\\r\"then return\"\\\\r\"elseif LM==\"\\t\"then return\"\\\\t\"elseif LM==\"\\b\"then return\"\\\\b\"elseif LM==\"\\f\"then return\"\\\\f\"elseif\
LM=='\"'then return'\\\\\"'elseif LM=='\\\\'then return'\\\\\\\\'else\
return string.format(\"\\\\u%04x\",LM:byte())end end;local JV='['..'\"'..\
'%\\\\'..'%z'..'\\001'..'-'..'\\031'..']'local function X(CN)\
local P=CN:gsub(JV,YE)return'\"'..P..'\"'end\
local function D(FP,W,K)local R={}local WUL={}local VG=false\
local WD\
for N in pairs(W)do\
if type(N)=='string'then table.insert(R,N)elseif type(N)=='number'then\
table.insert(WUL,N)\
if N<=0 or N>=math.huge then VG=true elseif not WD or N>WD then WD=N end else\
FP:onEncodeError(\"can't encode table with a key of type \"..type(N),K)end end\
if#R==0 and not VG then\
if#WUL>0 then return nil,WD elseif tostring(W)==\"JSON array\"then return nil elseif\
tostring(W)==\"JSON object\"then return{}else return nil end end;table.sort(R)local J\
if#WUL>0 then if FP.noKeyConversion then\
FP:onEncodeError(\"a table with both numeric and string keys could be an object or array; aborting\",K)end;J={}for Y,NN in\
pairs(W)do J[Y]=NN end;table.sort(WUL)\
for AZ,LBL in ipairs(WUL)do\
local KC=tostring(LBL)\
if J[KC]==nil then table.insert(R,KC)J[KC]=W[LBL]else\
FP:onEncodeError(\
\"conflict converting table with mixed-type keys into a JSON object: key \"..LBL..\" exists both as a string and a number.\",K)end end end;return R,nil,J end;local BT\
function BT(TZ,ZX,CL,GC,RZ)\
if ZX==nil then return'null'elseif type(ZX)=='string'then return X(ZX)elseif type(ZX)=='number'then\
if ZX~=ZX then return\
\"null\"elseif ZX>=math.huge then return\"1e+9999\"elseif ZX<=-math.huge then return\"-1e+9999\"else return\
tostring(ZX)end elseif type(ZX)=='boolean'then return tostring(ZX)elseif type(ZX)~='table'then\
TZ:onEncodeError(\
\"can't convert \"..type(ZX)..\" to JSON\",GC)else local YETL=ZX;if CL[YETL]then\
TZ:onEncodeError(\"table \"..tostring(YETL)..\" is a child of itself\",GC)else CL[YETL]=true end;local UH\
local IS,UK,LT=D(TZ,YETL,GC)\
if UK then local BY={}for i=1,UK do\
table.insert(BY,BT(TZ,YETL[i],CL,GC,RZ))end\
if RZ then\
UH=\"[ \"..table.concat(BY,\", \")..\" ]\"else UH=\"[\"..table.concat(BY,\",\")..\"]\"end elseif IS then local IE=LT or YETL\
if RZ then local Y={}local M=0\
for ZRK,ON in ipairs(IS)do\
local OU=BT(TZ,tostring(ON),CL,GC,\"\")M=math.max(M,#OU)table.insert(Y,OU)end;local AXX=RZ..\"    \"local AE=RZ..string.rep(\" \",M+2+4)\
local QY=\
\"%s%\"..string.format(\"%d\",M)..\"s: %s\"local G={}for C,H in ipairs(IS)do local HAH=BT(TZ,IE[H],CL,GC,AE)\
table.insert(G,string.format(QY,AXX,Y[C],HAH))end\
UH=\"{\\n\"..\
table.concat(G,\",\\n\")..\"\\n\"..RZ..\"}\"else local P={}for LY,IL in ipairs(IS)do local SC=BT(TZ,IE[IL],CL,GC,RZ)\
local DU=BT(TZ,tostring(IL),CL,GC,RZ)\
table.insert(P,string.format(\"%s:%s\",DU,SC))end;UH=\"{\"..\
table.concat(P,\",\")..\"}\"end else UH=\"[]\"end;CL[YETL]=false;return UH end end\
function A:encode(XRS,PZ)if type(self)~='table'or self.__index~=A then\
A:onEncodeError(\"JSON:encode must be called in method format\",PZ)end;return\
BT(self,XRS,{},PZ,nil)end\
function A:encode_pretty(RB,WQ)if type(self)~='table'or self.__index~=A then\
A:onEncodeError(\"JSON:encode_pretty must be called in method format\",WQ)end;return\
BT(self,RB,{},WQ,\"\")end;function A.__tostring()return\"JSON encode/decode package\"end\
A.__index=A;function A:new(ZJ)local DNL={}if ZJ then for W,LZ in pairs(ZJ)do DNL[W]=LZ end end;return\
setmetatable(DNL,A)end\
JSON=A:new()",
  [ "/lib" ] = true,
}